# -*- coding: utf-8 -*-
"""
================================================================================
V5 Backtest: Synthetic 2x Leveraged Strategy
================================================================================
å›æ¸¬æ¨™çš„ï¼šæ¨¡æ“¬ä¸€å€‹è¿½è¹¤ TWII æ—¥æ¼²è·Œå¹… 200% (2å€) çš„åˆæˆè³‡ç”¢ã€‚
é‚è¼¯ï¼šAsset_{t} = Asset_{t-1} * (1 + TWII_Change_Pct_{t} * 2)

ç­–ç•¥æ‘˜è¦ï¼š
1. è³‡é‡‘ï¼šåˆå§‹ 60è¬ï¼Œæ¯å¹´åˆå†æ³¨å…¥ 60è¬ã€‚
2. è²·å…¥ï¼š
   - æ¿¾ç¶²ï¼šæ”¶ç›¤ > MA120 (ç‰›å¸‚) ä¸” K < 90 (éè¶…è²·)ã€‚
   - AIï¼šBuy Confidence > 0.9ã€‚
   - è³‡é‡‘ï¼šå‰©é¤˜ç¾é‡‘ > 0ã€‚
   - å‹•ä½œï¼šéš”æ—¥é–‹ç›¤è²·å…¥ (Next Open)ã€‚
3. åŠ ç¢¼ (Position Sizing)ï¼š
   - Anti-Martingaleï¼šBase = Current_Cash * 20%ã€‚
   - ä¸Šé™ï¼šMin(Base, 120,000)ã€‚
4. è³£å‡ºï¼š
   - ç¨ç«‹å€‰ä½ç›£æ§ã€‚
   - åœæ (SL)ï¼š-10%ã€‚
   - åœåˆ© (TP)ï¼š+40%ã€‚
   - å¿½ç•¥ AI è³£è¨Šã€‚
   - äº¤æ˜“æˆæœ¬ï¼š0.15% (æ¯æ¬¡è²·è³£çš†æ‰£é™¤)ã€‚

Benchmark: Yearly Lump Sum on TWII (1x).

ä½œè€…ï¼šPhil Liang (Generated by Gemini)
æ—¥æœŸï¼š2026-01-11
================================================================================
"""

import os
import sys
import argparse
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from stable_baselines3 import PPO

# Windows UTF-8 è¨­å®š
if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

# è¨­å®š
PROJECT_PATH = os.path.dirname(os.path.abspath(__file__))
V5_MODELS_PATH = os.path.join(PROJECT_PATH, 'models_hybrid_v5')
RESULTS_PATH = os.path.join(PROJECT_PATH, 'results_backtest_v5_2x_god_fuse')
CACHE_DIR = os.path.join(PROJECT_PATH, 'data', 'processed')

DEFAULT_START_DATE = '2017-10-16'
DEFAULT_END_DATE = '2023-10-15'
INITIAL_CAPITAL = 400_000
YEARLY_INJECTION = 400_000
TRANSACTION_FEE = 0.0015

# [Modified Parameters - God Mode]
HARD_STOP_PCT = 0.20          # ç¡¬æ€§åœæ -20%
TRAIL_ACTIVATION_PCT = 0.20   # ç§»å‹•åœåˆ©å•Ÿå‹•é–€æª» +20%
TRAIL_CALLBACK_BASE = 0.10    # ç§»å‹•åœåˆ©å›æª”å®¹å¿ (åŸºç¤ 10%)
POSITION_SIZE_MAX = 10_000_000 # å–®ç­†é‡‘é¡ä¸Šé™ 1000è¬ (å¹¾ä¹ç„¡ä¸Šé™)

# [Circuit Breaker (Fuse) Parameters - Defaults]
CB_TRIGGER_THRESHOLD = -0.15   # è§¸ç™¼é»ï¼šç¸½è³‡ç”¢å¾æœ€é«˜é»å›è½ -15% (æ ¹æ“šåƒæ•¸æƒææœ€å„ª)
CB_RESET_THRESHOLD = -0.15     # é‡ç½®é»ï¼šå›æ’¤ç¸®å°è‡³ -15% è§£é™¤è­¦å ±
DELEVERAGE_RATIO = 0.50        # æ¸›å€‰æ¯”ä¾‹ï¼šå¼·åˆ¶è³£å‡ºæŒå€‰çš„ 50%
CB_COOLDOWN_DAYS = 10          # å†·å»æœŸï¼šè§¸ç™¼å¾Œè‡³å°‘ 10 å¤©ä¸æ¢å¾© (æ ¹æ“šæ•æ„Ÿåº¦æ¸¬è©¦æœ€å„ª)

plt.rcParams['font.sans-serif'] = ['Microsoft JhengHei', 'SimHei', 'Arial Unicode MS']
plt.rcParams['axes.unicode_minus'] = False


class SyntheticLeveragedAsset:
    """
    æ¨¡æ“¬ 2x æ§“æ¡¿è³‡ç”¢
    """
    def __init__(self, raw_df: pd.DataFrame):
        self.raw_df = raw_df.copy()
        self._calculate_synthetic_data()

    def _calculate_synthetic_data(self):
        # è¨ˆç®— TWII æ—¥æ¼²è·Œå¹…
        self.raw_df['pct_change'] = self.raw_df['Close'].pct_change().fillna(0)
        
        # åˆæˆè³‡ç”¢æ¼²è·Œå¹… = TWII * 2
        self.raw_df['syn_pct_change'] = self.raw_df['pct_change'] * 2
        
        # å»ºæ§‹åˆæˆåƒ¹æ ¼åºåˆ— (Base = 100)
        self.raw_df['Syn_Close'] = (1 + self.raw_df['syn_pct_change']).cumprod() * 100
        
        prev_close = self.raw_df['Close'].shift(1).fillna(method='bfill')
        twii_open_ret = (self.raw_df['Open'] / prev_close) - 1
        twii_high_ret = (self.raw_df['High'] / self.raw_df['Open']) - 1
        twii_low_ret = (self.raw_df['Low'] / self.raw_df['Open']) - 1
        
        syn_prev_close = self.raw_df['Syn_Close'].shift(1).fillna(100)
        
        self.raw_df['Syn_Open'] = syn_prev_close * (1 + twii_open_ret * 2)
        self.raw_df['Syn_High'] = self.raw_df['Syn_Open'] * (1 + twii_high_ret * 2)
        self.raw_df['Syn_Low'] = self.raw_df['Syn_Open'] * (1 + twii_low_ret * 2)
        
        # ä¿®æ­£: ç¢ºä¿ High >= Low
        self.raw_df['Syn_High'] = self.raw_df[['Syn_High', 'Syn_Low']].max(axis=1)
        self.raw_df['Syn_Low'] = self.raw_df[['Syn_High', 'Syn_Low']].min(axis=1)


class Position:
    def __init__(self, entry_date, entry_price, shares, cost_basis):
        self.entry_date = entry_date
        self.entry_price = entry_price
        self.shares = shares
        self.cost_basis = cost_basis
        
        # State Variables
        self.highest_price = entry_price  # Step A (Init)
        
        self.status = 'OPEN'
        self.exit_date = None
        self.exit_price = None
        self.exit_reason = None
        self.pnl = 0

    def check_exit(self, date, row_data):
        """
        æ¯æ—¥æ›´æ–°èˆ‡æª¢æŸ¥é‚è¼¯
        """
        open_p = row_data['Syn_Open']
        high_p = row_data['Syn_High']
        low_p = row_data['Syn_Low']
        
        # Step A: Update High
        if high_p > self.highest_price:
            self.highest_price = high_p
            
        # Step B: Calculate Thresholds
        stop_loss_price = self.entry_price * (1 - HARD_STOP_PCT)
        
        # Dynamic Trailing Callback
        max_profit_pct = (self.highest_price - self.entry_price) / self.entry_price
        current_callback = 0.15 if max_profit_pct > 0.50 else TRAIL_CALLBACK_BASE
        
        trail_stop_price = self.highest_price * (1 - current_callback)
        
        # Step C: Check Exit Conditions (Priority: Hard Stop > Trailing Stop)
        
        # Condition 1: Hard Stop
        # Check Low against Hard Stop
        if low_p <= stop_loss_price:
            # Check if Open was already below SL (Gap Down)
            exec_price = open_p if open_p <= stop_loss_price else stop_loss_price
            return self._close(date, exec_price, 'STOP_LOSS')
            
        # Condition 2: Trailing Stop
        # Check Activation
        price_gain_pct = (self.highest_price - self.entry_price) / self.entry_price
        if price_gain_pct >= TRAIL_ACTIVATION_PCT:
            # Check Low against Trail Stop
            if low_p <= trail_stop_price:
                # Check if Open was already below Trail Stop (Gap Down)
                # If Open < Trail Stop, we exit at Open.
                exec_price = open_p if open_p <= trail_stop_price else trail_stop_price
                return self._close(date, exec_price, 'TRAILING_PROFIT')
                
        return None

    def _close(self, date, price, reason):
        self.status = 'CLOSED'
        self.exit_date = date
        self.exit_price = price
        self.exit_reason = reason
        # Return Revenue
        return price * self.shares


class StrategyRunner:
    def __init__(self, buy_model, df: pd.DataFrame, cb_threshold=CB_TRIGGER_THRESHOLD, cb_cooldown=CB_COOLDOWN_DAYS, results_path=RESULTS_PATH):
        self.buy_model = buy_model
        self.df = df
        self.syn_asset = SyntheticLeveragedAsset(df)
        self.cash = INITIAL_CAPITAL
        self.positions = []
        self.closed_trades = []
        self.equity_curve = []
        self.total_invested = INITIAL_CAPITAL
        self.daily_logs = []
        
        # Circuit Breaker Settings (Configurable)
        self.cb_threshold = cb_threshold
        self.cb_cooldown = cb_cooldown
        self.results_path = results_path
        
        # Circuit Breaker State
        self.circuit_breaker_active = False
        self.peak_equity = INITIAL_CAPITAL
        self.cb_events = []
        self.cb_trigger_day_idx = None  # Track when CB was triggered (for cooldown)

    def run(self):
        dates = self.df.index
        current_year = None
        
        # æŒ‡æ¨™å¿«å–
        # Ensure MA60 exists
        if 'MA60' not in self.df.columns:
             self.df['MA60'] = self.df['Close'].rolling(window=60).mean()
        
        ma_vals = self.df['MA60'].values
        k_vals = self.df['K_raw'].values
        closes = self.df['Close'].values
        # AI Features
        # Assuming feature_cols are available in df
        import ptrl_hybrid_system as hybrid
        features = self.df[hybrid.FEATURE_COLS].values.astype(np.float32)

        # Pending Order
        pending_buy = None # (shares, projected_cost)

        print(f"Start Backtest: {dates[0].date()} ~ {dates[-1].date()}")
        print(f"Initial Cash: {self.cash}")

        for i in range(len(self.df)):
            date = dates[i]
            year = date.year
            
            # --- 1. Yearly Injection ---
            if current_year != year:
                current_year = year
                if i > 0: # Skip first day injection if it matches initial capital logic, but user said "Initial + Yearly"
                    # è¿™é‡Œå‡è®¾åˆå§‹èµ„é‡‘å³ä¸ºç¬¬ä¸€å¹´çš„èµ„é‡‘ï¼Œç¬¬äºŒå¹´å¼€å§‹æ¯å¹´åˆæ³¨å…¥
                    # ä½†User says: "ç¬¬1å¹´å¹´åˆæ³¨å…¥ 600,000... æ¯å¹´å¹´åˆé¡å¤–æ³¨å…¥ 600,000"
                    # So 2017 start -> 600k. 2018 start -> +600k.
                    pass
                if i > 0: # Only inject from 2nd year onwards in the loop
                    self.cash += YEARLY_INJECTION
                    self.total_invested += YEARLY_INJECTION
                    print(f"[{date.date()}] YEARLY INJECTION +{YEARLY_INJECTION} => Cash: {self.cash:.0f}")

            # Syn Data for today
            syn_row = self.syn_asset.raw_df.iloc[i]
            
            # --- 2. Execute Pending Buy (at Open) ---
            if pending_buy:
                # å¯¦éš›è²·å…¥
                amount_to_alloc = pending_buy
                open_price = syn_row['Syn_Open']
                
                # Re-calculate shares based on open price to match allocation limit strictly?
                # User: "å–®ç­†... Base=Cash*20%, Min(Base, 120k)" computed YESTERDAY.
                # So we allocated 'amount_to_alloc' TWD.
                # Fee calculation: 
                # If we want to spend exactly 'amount_to_alloc' including fee?
                # Usually: Value = Amount / (1 + fee).
                # User: "æ¯æ¬¡è²·å…¥...æ‰£é™¤äº¤æ˜“é‡‘é¡çš„ 0.15%" -> Usually means fee is extra.
                # Let's stick to: We commit `amount_to_alloc` from Cash.
                # Fee is `amount_to_alloc * 0.0015`. Total deduction = Amount + Fee.
                
                # Check if enough cash again (in case of limit order? no, market order)
                total_deduction = amount_to_alloc * (1 + TRANSACTION_FEE)
                
                if self.cash >= total_deduction:
                    shares = amount_to_alloc / open_price
                    self.cash -= total_deduction
                    
                    new_pos = Position(date, open_price, shares, amount_to_alloc)
                    self.positions.append(new_pos)
                    # print(f"  [BUY] {date.date()} @ {open_price:.2f}, Amt: {amount_to_alloc:.0f}, Shares: {shares:.2f}")
                else:
                    # Cancel if not enough cash (should not happen if logic is correct)
                    pass
                
                pending_buy = None

            # --- 3. Check Exits (Intraday) ---
            # Create a copy to modify list while iterating
            active_positions = []
            for pos in self.positions:
                revenue = pos.check_exit(date, syn_row)
                if revenue is not None:
                    # Position Closed
                    fee = revenue * TRANSACTION_FEE
                    net_in = revenue - fee
                    self.cash += net_in
                    
                    # Log Trade
                    ret_pct = (revenue - pos.cost_basis) / pos.cost_basis
                    self.closed_trades.append({
                        'entry_date': pos.entry_date,
                        'exit_date': date,
                        'entry_price': pos.entry_price,
                        'exit_price': pos.exit_price,
                        'reason': pos.exit_reason,
                        'return': ret_pct,
                        'profit': net_in - (pos.cost_basis * (1+TRANSACTION_FEE)),
                        'hold_days': (date - pos.entry_date).days
                    })
                    # print(f"  [SELL] {date.date()} {pos.exit_reason} @ {pos.exit_price:.2f}, Ret: {ret_pct*100:.1f}%")
                else:
                    active_positions.append(pos)
            self.positions = active_positions

            # --- 4. Check Entries (After Close) ---
            # Conditions:
            # 1. Close > MA60 (Modified from MA120)
            # 2. K < 100
            # 3. AI Buy Conf > 0.9
            # 4. Cash > 0
            
            ma_val = ma_vals[i]
            k_val = k_vals[i]
            close = closes[i]
            
            should_buy = False
            ai_conf = 0.0
            
            if not np.isnan(ma_val) and close > ma_val:
                # K Filter relaxed to 100 (effectively unchecked)
                if k_val < 100:
                    # AI Check
                    obs = np.nan_to_num(features[i], nan=0.0, posinf=1.0, neginf=-1.0).reshape(1, -1)
                    action, _ = self.buy_model.predict(obs, deterministic=True)
                    # Get Prob
                    probs = self.buy_model.policy.get_distribution(self.buy_model.policy.obs_to_tensor(obs)[0]).distribution.probs.detach().cpu().numpy()[0]
                    
                    # Logic: AI Action must be BUY (1) AND Prob > 0.9
                    if action[0] == 1:
                        ai_conf = float(probs[1])
                        if ai_conf > 0.90:
                            if self.cash > 1000: # Min cash threshold
                                should_buy = True

            if should_buy:
                # Sizing: Anti-Martingale Dynamic
                # Conf > 0.95 -> 25%
                # Else        -> 15%
                size_pct = 0.25 if ai_conf > 0.95 else 0.15
                
                base_amount = self.cash * size_pct
                trade_amount = min(base_amount, POSITION_SIZE_MAX)
                
                # Ensure min trade size? Maybe 10k
                if trade_amount >= 5000:
                   pending_buy = trade_amount  # Prepare for next Open

            # --- 5. Record Daily State ---
            # Total Equity = Cash + Position Value (at Close)
            pos_value = sum(p.shares * syn_row['Syn_Close'] for p in self.positions)
            total_equity = self.cash + pos_value
            
            # --- 5b. Circuit Breaker Logic ---
            # Update Peak
            if total_equity > self.peak_equity:
                self.peak_equity = total_equity
            
            # Calculate Drawdown
            current_dd = (total_equity - self.peak_equity) / self.peak_equity
            
            # State Machine
            if not self.circuit_breaker_active:
                # Normal Mode: Check for Trigger
                if current_dd <= self.cb_threshold:
                    self.circuit_breaker_active = True
                    self.cb_trigger_day_idx = i  # Record trigger day
                    self.cb_events.append({'date': date, 'event': 'TRIGGER', 'dd': current_dd, 'equity': total_equity})
                    print(f"[CB TRIGGER] {date.date()} DD={current_dd*100:.2f}% (Threshold: {self.cb_threshold*100:.0f}%) | Deleveraging...")
                    
                    # De-leverage: Sell 50% of all positions
                    positions_to_reduce = self.positions[:]
                    for pos in positions_to_reduce:
                        sell_shares = pos.shares * DELEVERAGE_RATIO
                        sell_price = syn_row['Syn_Close']  # Sell at close
                        revenue = sell_shares * sell_price
                        fee = revenue * TRANSACTION_FEE
                        net_in = revenue - fee
                        self.cash += net_in
                        
                        # Reduce position
                        pos.shares -= sell_shares
                        cost_reduction = pos.cost_basis * DELEVERAGE_RATIO
                        pos.cost_basis -= cost_reduction
                        
                        # Log as trade (partial exit)
                        self.closed_trades.append({
                            'entry_date': pos.entry_date,
                            'exit_date': date,
                            'entry_price': pos.entry_price,
                            'exit_price': sell_price,
                            'reason': 'CB_DELEVERAGE',
                            'return': (sell_price - pos.entry_price) / pos.entry_price,
                            'profit': net_in - (cost_reduction * (1+TRANSACTION_FEE)),
                            'hold_days': (date - pos.entry_date).days
                        })
                    
                    # Remove positions with near-zero shares
                    self.positions = [p for p in self.positions if p.shares > 0.01]
                    
                    # Recalculate after deleverage
                    pos_value = sum(p.shares * syn_row['Syn_Close'] for p in self.positions)
                    total_equity = self.cash + pos_value
                    
            else:
                # Defensive Mode: Check for Reset
                # Condition 1: DD must recover past reset threshold
                # Condition 2: Cooldown period must have passed
                days_since_trigger = i - self.cb_trigger_day_idx if self.cb_trigger_day_idx else 0
                cooldown_passed = days_since_trigger >= self.cb_cooldown
                
                if current_dd > CB_RESET_THRESHOLD and cooldown_passed:
                    self.circuit_breaker_active = False
                    self.cb_events.append({'date': date, 'event': 'RESET', 'dd': current_dd, 'equity': total_equity, 'cooldown_days': days_since_trigger})
                    print(f"[CB RESET] {date.date()} DD={current_dd*100:.2f}% (After {days_since_trigger} days) | Returning to Normal Mode")
                    
            # Halve pending buy if in defensive mode
            if self.circuit_breaker_active and pending_buy:
                pending_buy = pending_buy * 0.5
                # print(f"  [CB] Defensive Mode: Buy amount halved to {pending_buy:.0f}")
            
            self.equity_curve.append({
                'date': date,
                'equity': total_equity,
                'cash': self.cash,
                'positions': len(self.positions),
                'syn_price': syn_row['Syn_Close'],
                'twii_price': close,
                'ai_conf': ai_conf if should_buy else None,
                'cb_active': self.circuit_breaker_active,
                'dd': current_dd
            })
            
            self.daily_logs.append({
                'date': date,
                'action': 'BUY' if should_buy else ('HOLD' if len(self.positions)>0 else 'WAIT'),
                'positions': len(self.positions),
                'equity': total_equity
            })

        self.generate_end_date_report()
        return self._make_report()

    def generate_end_date_report(self):
        """
        Generate a summary report for the last date of the backtest.
        """
        if self.df.empty:
            return

        last_date = self.df.index[-1]
        last_idx = len(self.df) - 1
        
        # 1. Market Data
        syn_row = self.syn_asset.raw_df.iloc[last_idx]
        raw_row = self.df.iloc[last_idx]
        
        # 2. Indicators & AI
        ma60 = raw_row.get('MA60', 0)
        close = raw_row['Close']
        k_val = raw_row.get('K_raw', 0)
        
        # AI Prediction
        import ptrl_hybrid_system as hybrid
        # Need features for the last day to predict for tomorrow?
        # Actually in the loop we predict at index i for action at i+1 (Next Open).
        # So we take the last available feature vector.
        features = self.df[hybrid.FEATURE_COLS].values.astype(np.float32)
        last_obs = np.nan_to_num(features[last_idx], nan=0.0, posinf=1.0, neginf=-1.0).reshape(1, -1)
        action, _ = self.buy_model.predict(last_obs, deterministic=True)
        probs = self.buy_model.policy.get_distribution(self.buy_model.policy.obs_to_tensor(last_obs)[0]).distribution.probs.detach().cpu().numpy()[0]
        
        predicted_class = action[0]
        ai_conf = float(probs[predicted_class])
        ai_action_str = "BUY" if predicted_class == 1 else "WAIT"
        
        # 3. Portfolio State
        active_pos_count = len(self.positions)
        market_value = 0
        total_cost = 0
        
        pos_details = []
        syn_close = syn_row['Syn_Close'] # Use Syn Close for valuation
        
        for idx, pos in enumerate(self.positions):
            # Calc current stats
            current_val = pos.shares * syn_close
            market_value += current_val
            total_cost += pos.cost_basis
            
            roi_pct = (current_val - pos.cost_basis) / pos.cost_basis
            
            # Recalculate Thresholds for display
            # Note: pos.highest_price should be up to date from the run loop
            stop_loss_price = pos.entry_price * (1 - HARD_STOP_PCT)
            
            max_profit_pct = (pos.highest_price - pos.entry_price) / pos.entry_price
            current_callback = 0.15 if max_profit_pct > 0.50 else TRAIL_CALLBACK_BASE
            trail_stop_price = pos.highest_price * (1 - current_callback)
            
            # Determine effective stop
            # Logic in check_exit is: Hard Stop > Trailing Stop check
            
            # Activation check
            price_gain_pct = (pos.highest_price - pos.entry_price) / pos.entry_price
            is_trail_active = price_gain_pct >= TRAIL_ACTIVATION_PCT
            
            trail_status = f"{trail_stop_price:.2f}" if is_trail_active else "(æœªå•Ÿå‹•)"
            
            # --- Conversion to Real TWII ---
            # Formula: Target_TWII = Current_TWII * (1 + (Target_Syn - Current_Syn) / Current_Syn / 2)
            curr_syn = syn_close
            curr_twii = close
            
            # 1. Hard Stop
            sl_dist_pct = (stop_loss_price - curr_syn) / curr_syn
            est_twii_sl = curr_twii * (1 + sl_dist_pct / 2)
            
            # 2. Trail Stop
            if is_trail_active:
                trail_dist_pct = (trail_stop_price - curr_syn) / curr_syn
                est_twii_trail = curr_twii * (1 + trail_dist_pct / 2)
                trail_str_full = f"{trail_stop_price:.2f} (ç´„ TWII {est_twii_trail:,.0f})"
            else:
                trail_str_full = "(æœªå•Ÿå‹•)"

            detail_str = (
                f"   #{idx+1} è²·å…¥: {pos.entry_date.date()} @ {pos.entry_price:.2f}\n"
                f"       æˆæœ¬: ${pos.cost_basis:.0f} | å¸‚å€¼: ${current_val:.0f}\n"
                f"       å ±é…¬: {roi_pct*100:+.2f}% | æœ€é«˜åƒ¹: {pos.highest_price:.2f}\n"
                f"       ğŸ›‘ ç¡¬æ€§åœæ: {stop_loss_price:.2f} (ç´„ TWII {est_twii_sl:,.0f})\n"
                f"       ğŸ“‰ ç§»å‹•åœåˆ©: {trail_str_full} (å›æª” {current_callback*100:.0f}%)\n"
            )
            pos_details.append(detail_str)

        total_assets = self.cash + market_value
        unrealized_pnl = market_value - total_cost
        unrealized_pnl_pct = (unrealized_pnl / total_cost * 100) if total_cost > 0 else 0
        
        # 4. Generate Text
        lines = []
        lines.append("="*50)
        lines.append(f"ğŸ“… å ±å‘Šæ—¥æœŸ: {last_date.date()}")
        lines.append("="*50)
        lines.append("[å¸‚å ´æ•¸æ“š - çœŸå¯¦ TWII]")
        lines.append(f"ğŸ“Š Close: {raw_row['Close']:.2f}")
        lines.append(f"ğŸ“ˆ High:  {raw_row['High']:.2f}")
        lines.append(f"ğŸ“‰ Low:   {raw_row['Low']:.2f}")
        lines.append("-" * 30)
        lines.append(f"[å¸‚å ´æ•¸æ“š - Synthetic 2x Asset]")
        lines.append(f"ğŸ“Š Syn_Close: {syn_row['Syn_Close']:.2f}")
        lines.append(f"ğŸ“ˆ Syn_High:  {syn_row['Syn_High']:.2f}")
        lines.append(f"ğŸ“‰ Syn_Low:   {syn_row['Syn_Low']:.2f}")
        lines.append("-" * 30)
        lines.append("[æ¿¾ç¶²èˆ‡ AI ä¿¡è™Ÿ]")
        lines.append(f"   MA60: {ma60:.2f} | Close > MA60: {'âœ… YES' if close > ma60 else 'âŒ NO'}")
        lines.append(f"   KDå€¼: {k_val:.2f} | K < 100: {'âœ… YES' if k_val < 100 else 'âŒ NO'}")
        lines.append(f"   ğŸ¤– AI Action: {ai_action_str} (Conf: {ai_conf*100:.1f}%)")
        lines.append("-" * 50)
        lines.append("[å¸³æˆ¶ç‹€æ…‹]")
        lines.append(f"   ğŸ’µ ç¾é‡‘ (Cash):      ${self.cash:,.0f}")
        lines.append(f"   ğŸ’ æŒå€‰å¸‚å€¼ (Value): ${market_value:,.0f}")
        lines.append(f"   ğŸ¦ ç¸½è³‡ç”¢ (Total):   ${total_assets:,.0f}")
        lines.append(f"   ğŸ“ˆ æœªå¯¦ç¾æç›Š:       ${unrealized_pnl:,.0f} ({unrealized_pnl_pct:+.2f}%)")
        lines.append("-" * 50)
        lines.append(f"[æŒå€‰æ˜ç´°] (å…± {active_pos_count} å€‰)")
        for p in pos_details:
            lines.append(p)
        
        # ====== æ˜æ—¥äº¤æ˜“å»ºè­° ======
        lines.append("-" * 50)
        lines.append("[ğŸ”® æ˜æ—¥äº¤æ˜“å»ºè­° - é–‹ç›¤åŸ·è¡Œ]")
        lines.append("")
        
        # --- è²·å…¥å»ºè­° ---
        # æª¢æŸ¥æ‰€æœ‰è²·å…¥æ¢ä»¶
        ma_filter_pass = not np.isnan(ma60) and close > ma60
        k_filter_pass = k_val < 100
        ai_buy_signal = (predicted_class == 1) and (ai_conf > 0.90)
        has_cash = self.cash > 1000
        
        # è¨ˆç®—å»ºè­°è²·å…¥é‡‘é¡
        if ma_filter_pass and k_filter_pass and ai_buy_signal and has_cash:
            # æ ¹æ“šä¿¡å¿ƒåº¦æ±ºå®šè³‡é‡‘æ¯”ä¾‹
            size_pct = 0.25 if ai_conf > 0.95 else 0.15
            suggested_amount = min(self.cash * size_pct, POSITION_SIZE_MAX)
            fee_estimate = suggested_amount * TRANSACTION_FEE
            total_cost = suggested_amount + fee_estimate
            
            lines.append("   ğŸ“ˆ ã€è²·å…¥å»ºè­°ã€‘: âœ… å»ºè­°è²·å…¥")
            lines.append(f"      ğŸ’° å»ºè­°è²·å…¥é‡‘é¡: ${suggested_amount:,.0f}")
            lines.append(f"      ğŸ’¸ é ä¼°æ‰‹çºŒè²»:   ${fee_estimate:,.0f}")
            lines.append(f"      ğŸ’µ ç¸½æˆæœ¬æ”¯å‡º:   ${total_cost:,.0f}")
            lines.append(f"      ğŸ“Š è³‡é‡‘æ¯”ä¾‹:     {size_pct*100:.0f}% (AI ä¿¡å¿ƒåº¦ {'> 95%' if ai_conf > 0.95 else '90-95%'})")
            lines.append("")
            lines.append("      âœ… é€šéæ¢ä»¶:")
            lines.append(f"         - Close > MA60: {close:.2f} > {ma60:.2f}")
            lines.append(f"         - K < 100: {k_val:.2f}")
            lines.append(f"         - AI BUY ä¿¡å¿ƒåº¦: {ai_conf*100:.1f}%")
        else:
            lines.append("   ğŸ“ˆ ã€è²·å…¥å»ºè­°ã€‘: âŒ ä¸å»ºè­°è²·å…¥")
            lines.append(f"      ğŸ’° å»ºè­°è²·å…¥é‡‘é¡: $0")
            lines.append("")
            lines.append("      âŒ æœªé€šéæ¢ä»¶:")
            if not ma_filter_pass:
                lines.append(f"         - Close <= MA60: {close:.2f} {'<=' if not np.isnan(ma60) else 'N/A'} {ma60:.2f if not np.isnan(ma60) else 'N/A'}")
            if not k_filter_pass:
                lines.append(f"         - K >= 100: {k_val:.2f}")
            if not ai_buy_signal:
                if predicted_class != 1:
                    lines.append(f"         - AI Action ç‚º WAIT (é BUY)")
                elif ai_conf <= 0.90:
                    lines.append(f"         - AI ä¿¡å¿ƒåº¦ä¸è¶³: {ai_conf*100:.1f}% <= 90%")
            if not has_cash:
                lines.append(f"         - ç¾é‡‘ä¸è¶³: ${self.cash:,.0f} <= $1,000")
        
        lines.append("")
        lines.append("-" * 30)
        lines.append("")
        
        # --- è³£å‡ºå»ºè­° ---
        lines.append("   ğŸ“‰ ã€è³£å‡ºç›£æ§ã€‘: åœæ/åœåˆ©è§¸ç™¼åƒ¹ä½")
        lines.append("")
        
        if active_pos_count == 0:
            lines.append("      (ç„¡æŒå€‰)")
        else:
            # å€‹è‚¡åœæåƒ¹ä½å·²åœ¨æŒå€‰æ˜ç´°ä¸­é¡¯ç¤ºï¼Œé€™è£¡å½™æ•´
            lines.append("      âš ï¸ ç›£æ§å¤§ç›¤æŒ‡æ•¸å°æ‡‰çš„è§¸ç™¼é»ä½:")
            lines.append("")
            
            for idx, pos in enumerate(self.positions):
                # è¨ˆç®—å„ç¨®åœæåƒ¹ä½
                stop_loss_price = pos.entry_price * (1 - HARD_STOP_PCT)
                max_profit_pct = (pos.highest_price - pos.entry_price) / pos.entry_price
                current_callback = 0.15 if max_profit_pct > 0.50 else TRAIL_CALLBACK_BASE
                trail_stop_price = pos.highest_price * (1 - current_callback)
                
                price_gain_pct = (pos.highest_price - pos.entry_price) / pos.entry_price
                is_trail_active = price_gain_pct >= TRAIL_ACTIVATION_PCT
                
                # è¨ˆç®—å°æ‡‰çš„ TWII é»ä½
                curr_syn = syn_close
                curr_twii = close
                
                sl_dist_pct = (stop_loss_price - curr_syn) / curr_syn
                est_twii_sl = curr_twii * (1 + sl_dist_pct / 2)
                
                # è¨ˆç®—æŒå€‰å¸‚å€¼
                current_val = pos.shares * syn_close
                
                lines.append(f"      #å€‰{idx+1} (å¸‚å€¼ ${current_val:,.0f}):")
                lines.append(f"         ğŸ›‘ ç¡¬åœæè§¸ç™¼: å¤§ç›¤è·Œè‡³ {est_twii_sl:,.0f} é»æ™‚è³£å‡º")
                lines.append(f"            â†’ é è¨ˆæ”¶å›: ${current_val * (stop_loss_price/syn_close):,.0f}")
                
                if is_trail_active:
                    trail_dist_pct = (trail_stop_price - curr_syn) / curr_syn
                    est_twii_trail = curr_twii * (1 + trail_dist_pct / 2)
                    lines.append(f"         ğŸ“‰ ç§»å‹•åœåˆ©è§¸ç™¼: å¤§ç›¤è·Œè‡³ {est_twii_trail:,.0f} é»æ™‚è³£å‡º")
                    lines.append(f"            â†’ é è¨ˆæ”¶å›: ${current_val * (trail_stop_price/syn_close):,.0f}")
                else:
                    lines.append(f"         ğŸ“‰ ç§»å‹•åœåˆ©: æœªå•Ÿå‹• (éœ€æ¼² {TRAIL_ACTIVATION_PCT*100:.0f}%)")
                lines.append("")
            
            # å½™ç¸½ä»Šæ—¥è‹¥å…¨æ•¸è³£å‡ºçš„é ä¼°
            total_sell_value = sum(p.shares * syn_close for p in self.positions)
            sell_fee = total_sell_value * TRANSACTION_FEE
            net_sell = total_sell_value - sell_fee
            
            lines.append("      " + "-" * 25)
            lines.append(f"      ğŸ“Š è‹¥ä»Šæ—¥å…¨æ•¸è³£å‡º:")
            lines.append(f"         ç¸½å¸‚å€¼:     ${total_sell_value:,.0f}")
            lines.append(f"         é ä¼°æ‰‹çºŒè²»: ${sell_fee:,.0f}")
            lines.append(f"         æ·¨æ”¶å…¥:     ${net_sell:,.0f}")
        
        lines.append("")
        lines.append("="*50)
        
        # ====== ğŸš€ æ˜æ—¥æ“ä½œåŸ·è¡Œç¸½è¡¨ (Netting) ======
        lines.append("ğŸš€ æ˜æ—¥æ“ä½œåŸ·è¡Œç¸½è¡¨ (Netting)")
        lines.append("="*50)

        # 1. è¨ˆç®—é è¨ˆè³£å‡º (Pending Sell)
        # é‚è¼¯: æ‰¾å‡ºå›æ¸¬ä¸­ã€ä»Šå¤©ã€‘(last_date) è¢«çµæ¸…çš„äº¤æ˜“
        # é€™äº›ä»£è¡¨ä»Šå¤©ç›¤ä¸­æˆ–æ”¶ç›¤è§¸ç™¼äº†å‡ºå ´æ¢ä»¶ï¼ŒUser éœ€åœ¨æ˜å¤©é–‹ç›¤è£œè³£
        pending_sell_amount = 0.0
        sell_reasons = []
        
        today_sells = [t for t in self.closed_trades if t['exit_date'] == last_date]
        
        # åŠ ä¸Šå¯èƒ½çš„èæ–·æ¸›å€‰ (é›–ç„¶ä¹Ÿæ˜¯ tradeï¼Œä½†å¯èƒ½éœ€è¦ç‰¹åˆ¥æ¨™è¨»)
        # å…¶å¯¦ closed_trades è£¡å·²ç¶“åŒ…å«äº†é€™éƒ¨åˆ† (reason='CB_DELEVERAGE')
        
        for t in today_sells:
            # å¿…é ˆåæ¨æ­¤ç­†äº¤æ˜“è³£å‡ºçš„é‡‘é¡ (Revenue)
            # å…¬å¼: Profit = Revenue * (1-Fee) - EntryCost * (1+Fee)
            #       Shares = Profit / [ Exit*(1-Fee) - Entry*(1+Fee) ]
            #       Revenue = Shares * Exit
            
            try:
                term = t['exit_price'] * (1 - TRANSACTION_FEE) - t['entry_price'] * (1 + TRANSACTION_FEE)
                if abs(term) < 1e-9:
                    calc_shares = 0
                else:
                    calc_shares = t['profit'] / term
            except:
                calc_shares = 0
            
            if calc_shares > 0:
                sell_val = calc_shares * t['exit_price']
                pending_sell_amount += sell_val
                sell_reasons.append(f"{t['reason']} (ç´„ ${sell_val:,.0f})")

        # 2. è¨ˆç®—é è¨ˆè²·é€² (Pending Buy)
        # æ ¹æ“šæ˜æ—¥å»ºè­°å€å¡Šçš„è®Šæ•¸ä¾†è¨ˆç®—
        pending_buy_amount = 0.0
        # é€™è£¡éœ€è¦é‡è¤‡ä¸€æ¬¡åˆ¤æ–·é‚è¼¯ï¼Œç¢ºä¿è®Šæ•¸å¯å­˜å–
        ma_filter_pass = not np.isnan(ma60) and close > ma60
        k_filter_pass = k_val < 100
        ai_buy_signal = (predicted_class == 1) and (ai_conf > 0.90)
        has_cash = self.cash > 1000
        
        if ma_filter_pass and k_filter_pass and ai_buy_signal and has_cash:
             size_pct = 0.25 if ai_conf > 0.95 else 0.15
             pending_buy_amount = min(self.cash * size_pct, POSITION_SIZE_MAX)

        # 3. æ·¨é¡è¨ˆç®—
        net_amount = pending_buy_amount - pending_sell_amount
        
        # 4. ç”Ÿæˆå ±å‘Šæ–‡å­—
        lines.append(f"1. é è¨ˆè³£å‡ºç¸½é¡: ${pending_sell_amount:,.0f}")
        for r in sell_reasons:
            lines.append(f"   - {r}")
        if not sell_reasons:
             lines.append("   - ç„¡ (ä»Šæ—¥å›æ¸¬ç„¡è§¸ç™¼è³£è¨Š)")

        lines.append(f"2. é è¨ˆè²·é€²ç¸½é¡: ${pending_buy_amount:,.0f}")
        if pending_buy_amount > 0:
             lines.append(f"   - AI å»ºè­°è²·é€² (ä¿¡å¿ƒåº¦ {ai_conf*100:.1f}%)")
        else:
             lines.append("   - ç„¡ (æœªæ»¿è¶³è²·å…¥æ¢ä»¶)")

        lines.append("-" * 30)
        
        if net_amount > 0:
            lines.append(f"âš–ï¸ ã€æœ€çµ‚æŒ‡ä»¤ã€‘: ğŸŸ¢ åŠ ç¢¼è²·é€² (Net Buy)")
            lines.append(f"ğŸ‘‰ è«‹æ›å–®è²·é€²: ${net_amount:,.0f}")
            lines.append(f"   (è²·å…¥ ${pending_buy_amount:,.0f} - è³£å‡º ${pending_sell_amount:,.0f})")
        elif net_amount < 0:
            lines.append(f"âš–ï¸ ã€æœ€çµ‚æŒ‡ä»¤ã€‘: ğŸ”´ éƒ¨åˆ†è®Šç¾ (Net Sell)")
            lines.append(f"ğŸ‘‰ è«‹æ›å–®è³£å‡º: ${abs(net_amount):,.0f}")
            lines.append(f"   (è³£å‡º ${pending_sell_amount:,.0f} - è²·å…¥ ${pending_buy_amount:,.0f})")
        else:
            lines.append(f"âš–ï¸ ã€æœ€çµ‚æŒ‡ä»¤ã€‘: âšª ç„¡å‹•ä½œ (HOLD)")
            lines.append(f"   (è²·è³£ç›¸æŠµæˆ–ç„¡äº¤æ˜“)")
        
        report_content = "\n".join(lines)
        
        # Save
        filename = f"end_date_summary_{self.df.index[0].date().strftime('%Y%m%d')}_{self.df.index[-1].date().strftime('%Y%m%d')}.txt"
        out_path = os.path.join(self.results_path, filename)
        with open(out_path, 'w', encoding='utf-8') as f:
            f.write(report_content)
        print(f"End Date Summary saved to: {out_path}")

    def _make_report(self):
        eq_df = pd.DataFrame(self.equity_curve).set_index('date')
        
        # Metrics
        final_val = eq_df['equity'].iloc[-1]
        total_ret = (final_val - self.total_invested) / self.total_invested
        
        # Max DD
        roll_max = eq_df['equity'].cummax()
        drawdown = (eq_df['equity'] - roll_max) / roll_max
        max_dd = drawdown.min()
        
        # Sharpe
        daily_ret = eq_df['equity'].pct_change().fillna(0)
        sharpe = (daily_ret.mean() * 252) / (daily_ret.std() * np.sqrt(252)) if daily_ret.std() > 0 else 0
        
        # Trades
        win_rate = 0
        if self.closed_trades:
            wins = sum(1 for t in self.closed_trades if t['return'] > 0)
            win_rate = wins / len(self.closed_trades)
            
        return {
            'equity_df': eq_df,
            'trades': self.closed_trades,
            'final_value': final_val,
            'total_invested': self.total_invested,
            'total_return': total_ret,
            'max_drawdown': max_dd,
            'sharpe': sharpe,
            'win_rate': win_rate,
            'total_trades': len(self.closed_trades)
        }


def calculate_yearly_lumpsum_benchmark(df: pd.DataFrame, initial_capital=600_000, yearly_injection=600_000):
    """
    Benchmark: Yearly Lump Sum into TWII
    """
    cash = INITIAL_CAPITAL
    shares = 0
    total_invested = INITIAL_CAPITAL
    equity = []
    
    dates = df.index
    closes = df['Close'].values
    opens = df['Open'].values
    
    current_year = None
    
    for i in range(len(df)):
        date = dates[i]
        year = date.year
        price = closes[i]
        
        # Injection
        if current_year != year:
            current_year = year
            if i > 0:
                cash += yearly_injection
                total_invested += yearly_injection
            
            # Buy immediately at start of year (Lump Sum)
            # Use Open price of first day of year? or Close? 
            # Usually Lump Sum means "Buy on first trading day".
            # To be realistic, buy at Open of first day of year.
            buy_price = opens[i]
            if cash > 0:
                shares_bought = cash / buy_price
                shares += shares_bought
                cash = 0 # All in
        
        val = shares * price + cash
        equity.append({'date': date, 'benchmark_equity': val})
        
    bench_df = pd.DataFrame(equity).set_index('date')
    
    # Metrics
    final = bench_df['benchmark_equity'].iloc[-1]
    ret = (final - total_invested) / total_invested
    dd = (bench_df['benchmark_equity'] - bench_df['benchmark_equity'].cummax()) / bench_df['benchmark_equity'].cummax()
    max_dd = dd.min()
    
    daily_ret = bench_df['benchmark_equity'].pct_change().fillna(0)
    sharpe = (daily_ret.mean() * 252) / (daily_ret.std() * np.sqrt(252)) if daily_ret.std() > 0 else 0
    
    return {
        'equity_df': bench_df,
        'final_value': final,
        'total_invested': total_invested,
        'total_return': ret,
        'max_drawdown': max_dd,
        'sharpe': sharpe
    }


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--start', default=DEFAULT_START_DATE)
    parser.add_argument('--end', default=DEFAULT_END_DATE)
    parser.add_argument('--cb-threshold', type=float, default=CB_TRIGGER_THRESHOLD,
                        help='Circuit Breaker trigger threshold (e.g., -0.25 for -25%)')
    parser.add_argument('--cb-cooldown', type=int, default=CB_COOLDOWN_DAYS,
                        help='Cooldown days after CB trigger before reset is allowed')
    args = parser.parse_args()
    
    start_date = pd.Timestamp(args.start)
    end_date = pd.Timestamp(args.end)
    if end_date < start_date:
        end_date = pd.Timestamp.now().normalize()
    
    # Dynamic results path based on parameters
    threshold_str = f"{int(abs(args.cb_threshold)*100)}pct"
    cooldown_str = f"cd{args.cb_cooldown}"
    results_path = os.path.join(PROJECT_PATH, f'results_backtest_v5_2x_god_fuse_cb{threshold_str}_{cooldown_str}')
    os.makedirs(results_path, exist_ok=True)
    
    # Load Models
    print("Loading Models...")
    buy_model = PPO.load(os.path.join(V5_MODELS_PATH, 'ppo_buy_twii_final.zip'))
    
    # Load Data
    print("Loading Data...")
    import ptrl_hybrid_system as hybrid
    twii_raw = hybrid._load_local_twii_data(start_date="2000-01-01")
    twii_full = hybrid.calculate_features(twii_raw, twii_raw, ticker="^TWII", use_cache=False)
    
    df = twii_full[(twii_full.index >= start_date) & (twii_full.index <= end_date)].copy()
    
    if len(df) == 0:
        print("No data found.")
        return

    # Run Strategy
    print(f"Running 2x Strategy with CB Threshold={args.cb_threshold*100:.0f}%, Cooldown={args.cb_cooldown} days...")
    runner = StrategyRunner(buy_model, df, 
                            cb_threshold=args.cb_threshold, 
                            cb_cooldown=args.cb_cooldown,
                            results_path=results_path)
    res = runner.run()
    
    # Run Benchmark
    print("Running Benchmark...")
    bench = calculate_yearly_lumpsum_benchmark(df, INITIAL_CAPITAL, YEARLY_INJECTION)
    
    # Visualization & Output
    print_comparison(res, bench)
    save_results(res, bench, runner.syn_asset.raw_df, runner.positions, results_path, start_date, end_date)


def print_comparison(strat, bench):
    print("\n" + "="*80)
    print("Strategy Comparison: 2x Synthetic vs Yearly Lump Sum")
    print("="*80)
    print(f"{'Metric':<25} {'Strat 2x':>15} {'Benchmark (TWII)':>20}")
    print("-" * 80)
    print(f"{'Total Invested':<25} ${strat['total_invested']:>14,.0f} ${bench['total_invested']:>19,.0f}")
    print(f"{'Final Value':<25} ${strat['final_value']:>14,.0f} ${bench['final_value']:>19,.0f}")
    print(f"{'Total Return':<25} {strat['total_return']*100:>14.2f}% {bench['total_return']*100:>19.2f}%")
    print(f"{'Sharpe Ratio':<25} {strat['sharpe']:>15.2f} {bench['sharpe']:>20.2f}")
    print(f"{'Max Drawdown':<25} {strat['max_drawdown']*100:>14.2f}% {bench['max_drawdown']*100:>19.2f}%")
    print(f"{'Total Trades':<25} {strat['total_trades']:>15} {'N/A':>20}")
    print(f"{'Win Rate':<25} {strat['win_rate']*100:>14.1f}% {'N/A':>20}")
    print("="*80)


def save_results(strat, bench, syn_df, open_positions, path, start, end):
    s_str = start.strftime('%Y%m%d')
    e_str = end.strftime('%Y%m%d')
    
    # 1. Comparison CSV
    comp = pd.DataFrame({
        'Metric': ['Total Invested', 'Final Value', 'Total Return', 'Sharpe', 'Max DD', 'Trades', 'Win Rate'],
        'Strat_2x': [strat['total_invested'], strat['final_value'], strat['total_return'], strat['sharpe'], strat['max_drawdown'], strat['total_trades'], strat['win_rate']],
        'Benchmark': [bench['total_invested'], bench['final_value'], bench['total_return'], bench['sharpe'], bench['max_drawdown'], 0, 0]
    })
    comp.to_csv(os.path.join(path, f'metrics_comparison_{s_str}_{e_str}.csv'), index=False)
    
    # 2. Trades
    if strat['trades']:
        pd.DataFrame(strat['trades']).to_csv(os.path.join(path, f'trades_strat2x_{s_str}_{e_str}.csv'), index=False)

    # 3. Chart
    fig, axes = plt.subplots(3, 1, figsize=(12, 18))
    
    # Equity
    ax1 = axes[0]
    ax1.plot(strat['equity_df'].index, strat['equity_df']['equity'], label='Strat 2x', color='blue')
    ax1.plot(bench['equity_df'].index, bench['equity_df']['benchmark_equity'], label='Yearly Lump Sum (TWII)', color='gray', alpha=0.7)
    ax1.set_title('Equity Curve Comparison')
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    
    # 2x Asset Price & Signals
    ax2 = axes[1]
    # Plot Synthetic Close
    # Need to align syn_df with backtest range
    idx_range = strat['equity_df'].index
    syn_slice = syn_df.loc[idx_range]
    ax2.plot(syn_slice.index, syn_slice['Syn_Close'], label='Synthetic 2x Price', color='black', alpha=0.5)
    
    # Signals - Closed Trades
    trades = strat['trades']
    if trades:
        buys = [(t['entry_date'], t['entry_price']) for t in trades]
        exits = [(t['exit_date'], t['exit_price'], t['reason']) for t in trades]
        
        bx, by = zip(*buys)
        ax2.scatter(bx, by, marker='^', color='green', label='Buy (Closed)', s=50, zorder=5)
        
        sx, sy, sr = zip(*exits)
        colors = ['red' if 'SL' in r else 'purple' for r in sr]
        ax2.scatter(sx, sy, marker='v', c=colors, label='Sell', s=50, zorder=5)
    
    # Signals - Open Positions (Still Holding)
    if open_positions:
        open_buys = [(p.entry_date, p.entry_price) for p in open_positions]
        obx, oby = zip(*open_buys)
        ax2.scatter(obx, oby, marker='s', color='blue', label='Buy (Holding)', s=60, zorder=5, edgecolors='black')
        
    ax2.set_title('Synthetic 2x Asset & Trades')
    ax2.legend()
    ax2.grid(True, alpha=0.3)
    
    # Positions
    ax3 = axes[2]
    # Access position history from equity df if valid, or reconstruct
    # Since we saved 'positions' count in equity_df
    ax3.fill_between(strat['equity_df'].index, 0, strat['equity_df']['positions'], color='orange', alpha=0.5, label='Open Positions')
    ax3.set_title('Active Position Count')
    ax3.legend()
    ax3.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.savefig(os.path.join(path, f'chart_strat2x_{s_str}_{e_str}.png'))
    plt.close()
    
    print(f"Results saved to {path}")

if __name__ == '__main__':
    main()
