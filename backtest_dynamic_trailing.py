#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
================================================================================
US Tech Stock - æ·±åº¦å›æ¸¬è…³æœ¬ (Dynamic Trailing Stop)
================================================================================
é‡å° PLTR, NVDA, TSLA, NFLX é€²è¡Œæ·±åº¦å›æ¸¬ã€‚

å›æ¸¬è¨­å®š:
- æœŸé–“: 2017-10-16 ~ 2023-10-15
- åˆå§‹è³‡é‡‘: $1,000,000
- ä¿¡å¿ƒåº¦é–€æª»: > 90%
- åŸºæº–: ^IXIC Buy & Hold

é¢¨éšªç®¡ç†æ©Ÿåˆ¶:
- ç¡¬æ€§åœæ (Hard Stop): -8%
- ç§»å‹•åœåˆ©å•Ÿå‹•é–€æª»: +15%
- å‹•æ…‹å›æª”åœåˆ©:
  - ä¸€èˆ¬å€ (15-25%): å›æª” 8% å‡ºå ´
  - é«˜ç²åˆ©å€ (>25%): å›æª” 11% å‡ºå ´

ä½œè€…ï¼šPhil Liang (Generated by Gemini)
æ—¥æœŸï¼š2026-01-18
================================================================================
"""

import os
import sys
import json
import torch
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime
from tqdm import tqdm

if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

plt.rcParams['font.sans-serif'] = ['Microsoft JhengHei', 'SimHei', 'Arial Unicode MS']
plt.rcParams['axes.unicode_minus'] = False

from train_us_tech_buy_agent import (
    load_or_update_local_csv,
    calculate_features,
    BENCHMARK, FEATURE_COLS, VAL_RANGE, MODELS_PATH
)

from stable_baselines3 import PPO


# =============================================================================
# å›æ¸¬åƒæ•¸
# =============================================================================
TARGET_TICKERS = ["PLTR", "NVDA", "TSLA", "NFLX"]
VAL_START, VAL_END = VAL_RANGE
INITIAL_CAPITAL = 1_000_000

# é€²å ´æ¢ä»¶
CONFIDENCE_THRESHOLD = 0.90

# é¢¨éšªç®¡ç†åƒæ•¸
HARD_STOP_PCT = -0.08          # ç¡¬æ€§åœæ -8%
TRAILING_ACTIVATION = 0.15     # ç§»å‹•åœåˆ©å•Ÿå‹• +15%
HIGH_PROFIT_THR = 0.25         # é«˜ç²åˆ©å€é–€æª» +25%
CALLBACK_BASE = 0.08           # ä¸€èˆ¬å€å›æª”å®¹å¿åº¦ 8%
CALLBACK_HIGH = 0.11           # é«˜ç²åˆ©å€å›æª”å®¹å¿åº¦ 11%

OUTPUT_DIR = "backtest_results"


# =============================================================================
# æ¨¡å‹è¼‰å…¥
# =============================================================================
def load_model_manifest(models_path: str) -> dict:
    manifest_path = os.path.join(models_path, "model_manifest.json")
    if not os.path.exists(manifest_path):
        return None
    with open(manifest_path, 'r', encoding='utf-8') as f:
        return json.load(f)


def load_ticker_model(ticker: str, manifest: dict) -> PPO:
    if ticker not in manifest.get("tickers", {}):
        return None
    model_path = manifest["tickers"][ticker]["model_path"]
    if not os.path.exists(model_path):
        return None
    return PPO.load(model_path, device="cpu")


def get_action_confidence(model: PPO, obs: np.ndarray) -> tuple:
    obs_tensor = torch.as_tensor(obs.reshape(1, -1), dtype=torch.float32)
    with torch.no_grad():
        distribution = model.policy.get_distribution(obs_tensor)
        probs = distribution.distribution.probs.numpy()[0]
        action, _ = model.predict(obs, deterministic=True)
        return int(action), float(probs[1])


# =============================================================================
# å›æ¸¬å¼•æ“
# =============================================================================
class DynamicTrailingBacktester:
    """å‹•æ…‹å›æª”åœåˆ©å›æ¸¬å™¨"""
    
    def __init__(self, initial_capital: float = INITIAL_CAPITAL):
        self.initial_capital = initial_capital
        self.trades = []
        self.equity_curve = []
        self.buy_signals = []
        self.sell_signals = []  # (date, price, reason)
    
    def run(self, ticker: str, model: PPO, features_df: pd.DataFrame) -> dict:
        """åŸ·è¡Œå›æ¸¬"""
        # éæ¿¾æ¸¬è©¦æœŸé–“
        test_df = features_df[
            (features_df.index >= pd.Timestamp(VAL_START)) &
            (features_df.index <= pd.Timestamp(VAL_END))
        ].copy()
        
        if len(test_df) == 0:
            return None
        
        capital = self.initial_capital
        position = None  # {'shares', 'buy_price', 'buy_date', 'buy_idx', 'highest_price'}
        
        dates = test_df.index.tolist()
        closes = test_df['Close'].values
        highs = test_df['High'].values
        lows = test_df['Low'].values
        features = test_df[FEATURE_COLS].values.astype(np.float32)
        
        for i in tqdm(range(len(test_df)), desc=f"  Backtesting {ticker}", leave=False):
            date = dates[i]
            price = closes[i]
            high = highs[i]
            low = lows[i]
            
            # è¨˜éŒ„æ·¨å€¼
            if position:
                current_value = capital + position['shares'] * price
            else:
                current_value = capital
            self.equity_curve.append({'date': date, 'value': current_value})
            
            # =====================================================================
            # æŒæœ‰ä¸­ï¼šæª¢æŸ¥å‡ºå ´æ¢ä»¶
            # =====================================================================
            if position is not None:
                buy_price = position['buy_price']
                current_return = price / buy_price - 1
                highest_return = position['highest_price'] / buy_price - 1
                drawdown_from_high = (position['highest_price'] - price) / position['highest_price']
                
                # æ›´æ–°æœ€é«˜åƒ¹
                if price > position['highest_price']:
                    position['highest_price'] = price
                
                sell_reason = None
                
                # A. ç¡¬æ€§åœææª¢æŸ¥ (-8%)
                if current_return <= HARD_STOP_PCT:
                    sell_reason = "Hard Stop"
                
                # B. ç§»å‹•åœåˆ©é‚è¼¯
                elif highest_return >= TRAILING_ACTIVATION:
                    # åˆ¤æ–·å›æª”å®¹å¿åº¦
                    if highest_return >= HIGH_PROFIT_THR:
                        callback_limit = CALLBACK_HIGH
                    else:
                        callback_limit = CALLBACK_BASE
                    
                    if drawdown_from_high >= callback_limit:
                        sell_reason = f"Trailing Stop ({callback_limit:.0%})"
                
                # åŸ·è¡Œè³£å‡º
                if sell_reason:
                    sell_value = position['shares'] * price
                    profit = sell_value - position['shares'] * buy_price
                    capital += sell_value
                    
                    self.trades.append({
                        'ticker': ticker,
                        'buy_date': position['buy_date'],
                        'buy_price': buy_price,
                        'sell_date': date,
                        'sell_price': price,
                        'return': current_return,
                        'profit': profit,
                        'hold_days': i - position['buy_idx'],
                        'exit_reason': sell_reason,
                        'max_return': highest_return
                    })
                    self.sell_signals.append((date, price, sell_reason))
                    position = None
            
            # =====================================================================
            # ç©ºæ‰‹ï¼šæª¢æŸ¥é€²å ´æ¢ä»¶
            # =====================================================================
            elif position is None:
                obs = features[i]
                action, confidence = get_action_confidence(model, obs)
                
                # é€²å ´æ¢ä»¶ï¼šAction=1 ä¸” ä¿¡å¿ƒåº¦ > 90%
                if action == 1 and confidence > CONFIDENCE_THRESHOLD:
                    invest_amount = capital * 0.95  # ä½¿ç”¨ 95% è³‡é‡‘
                    shares = int(invest_amount / price)
                    
                    if shares > 0:
                        cost = shares * price
                        capital -= cost
                        
                        position = {
                            'shares': shares,
                            'buy_price': price,
                            'buy_date': date,
                            'buy_idx': i,
                            'highest_price': price,
                            'confidence': confidence
                        }
                        self.buy_signals.append((date, price, confidence))
        
        # å¼·åˆ¶å¹³å€‰ (å›æ¸¬çµæŸæ™‚)
        if position is not None:
            final_price = closes[-1]
            sell_value = position['shares'] * final_price
            profit = sell_value - position['shares'] * position['buy_price']
            capital += sell_value
            current_return = final_price / position['buy_price'] - 1
            
            self.trades.append({
                'ticker': ticker,
                'buy_date': position['buy_date'],
                'buy_price': position['buy_price'],
                'sell_date': dates[-1],
                'sell_price': final_price,
                'return': current_return,
                'profit': profit,
                'hold_days': len(test_df) - position['buy_idx'],
                'exit_reason': 'End of Test',
                'max_return': position['highest_price'] / position['buy_price'] - 1
            })
        
        return self._calculate_metrics(test_df, ticker)
    
    def _calculate_metrics(self, test_df: pd.DataFrame, ticker: str) -> dict:
        """è¨ˆç®—ç¸¾æ•ˆæŒ‡æ¨™"""
        if not self.equity_curve:
            return None
        
        equity_df = pd.DataFrame(self.equity_curve)
        equity_df['date'] = pd.to_datetime(equity_df['date'])
        equity_df.set_index('date', inplace=True)
        
        initial = self.initial_capital
        final = equity_df['value'].iloc[-1]
        total_return = (final - initial) / initial
        
        days = (equity_df.index[-1] - equity_df.index[0]).days
        years = days / 365.0
        cagr = (1 + total_return) ** (1 / years) - 1 if years > 0 else 0
        
        daily_returns = equity_df['value'].pct_change().dropna()
        if len(daily_returns) > 0 and daily_returns.std() > 0:
            sharpe = (daily_returns.mean() * 252 - 0.02) / (daily_returns.std() * np.sqrt(252))
        else:
            sharpe = 0
        
        rolling_max = equity_df['value'].cummax()
        drawdown = (equity_df['value'] - rolling_max) / rolling_max
        max_drawdown = drawdown.min()
        
        if self.trades:
            wins = sum(1 for t in self.trades if t['return'] > 0)
            win_rate = wins / len(self.trades)
            avg_return = np.mean([t['return'] for t in self.trades])
            avg_hold_days = np.mean([t['hold_days'] for t in self.trades])
        else:
            win_rate = 0
            avg_return = 0
            avg_hold_days = 0
        
        return {
            'ticker': ticker,
            'initial_capital': initial,
            'final_value': final,
            'total_return': total_return,
            'cagr': cagr,
            'sharpe_ratio': sharpe,
            'max_drawdown': max_drawdown,
            'total_trades': len(self.trades),
            'win_rate': win_rate,
            'avg_return': avg_return,
            'avg_hold_days': avg_hold_days,
            'equity_df': equity_df,
            'trades': self.trades,
            'test_start': test_df.index[0],
            'test_end': test_df.index[-1]
        }


# =============================================================================
# Nasdaq Benchmark
# =============================================================================
def calculate_benchmark(benchmark_df: pd.DataFrame) -> dict:
    """è¨ˆç®— Nasdaq Buy & Hold ç¸¾æ•ˆ"""
    test_df = benchmark_df[
        (benchmark_df.index >= pd.Timestamp(VAL_START)) &
        (benchmark_df.index <= pd.Timestamp(VAL_END))
    ]
    
    if len(test_df) == 0:
        return None
    
    initial_price = test_df['Close'].iloc[0]
    final_price = test_df['Close'].iloc[-1]
    total_return = (final_price - initial_price) / initial_price
    
    days = (test_df.index[-1] - test_df.index[0]).days
    years = days / 365.0
    cagr = (1 + total_return) ** (1 / years) - 1 if years > 0 else 0
    
    equity = test_df['Close'] / initial_price * INITIAL_CAPITAL
    rolling_max = equity.cummax()
    drawdown = (equity - rolling_max) / rolling_max
    max_drawdown = drawdown.min()
    
    daily_returns = test_df['Close'].pct_change().dropna()
    if len(daily_returns) > 0 and daily_returns.std() > 0:
        sharpe = (daily_returns.mean() * 252 - 0.02) / (daily_returns.std() * np.sqrt(252))
    else:
        sharpe = 0
    
    return {
        'ticker': '^IXIC (Benchmark)',
        'total_return': total_return,
        'cagr': cagr,
        'sharpe_ratio': sharpe,
        'max_drawdown': max_drawdown,
        'equity': equity
    }


# =============================================================================
# è¦–è¦ºåŒ–
# =============================================================================
def plot_equity_curves(all_results: list, benchmark: dict, output_dir: str):
    """ç¹ªè£½ç´¯ç©æ·¨å€¼æ›²ç·š"""
    fig, ax = plt.subplots(figsize=(14, 8))
    
    # ç¹ªè£½å„è‚¡ç­–ç•¥æ›²ç·š
    colors = ['#E91E63', '#4CAF50', '#2196F3', '#FF9800']
    for i, r in enumerate(all_results):
        if r is None:
            continue
        equity = r['equity_df']['value']
        ax.plot(equity.index, equity.values, label=f"{r['ticker']} (Return: {r['total_return']:.1%})",
                linewidth=2, color=colors[i % len(colors)])
    
    # ç¹ªè£½ Benchmark
    if benchmark:
        ax.plot(benchmark['equity'].index, benchmark['equity'].values, 
                label=f"^IXIC B&H ({benchmark['total_return']:.1%})",
                linewidth=2, linestyle='--', color='gray', alpha=0.7)
    
    ax.axhline(y=INITIAL_CAPITAL, color='black', linestyle=':', alpha=0.5, label='Initial Capital')
    
    ax.set_title(f'ç´¯ç©æ·¨å€¼æ›²ç·š (Confidence > {CONFIDENCE_THRESHOLD:.0%})\n{VAL_START} ~ {VAL_END}', fontsize=14)
    ax.set_xlabel('Date', fontsize=11)
    ax.set_ylabel('Portfolio Value ($)', fontsize=11)
    ax.legend(loc='upper left', fontsize=10)
    ax.grid(True, alpha=0.3)
    ax.set_ylim(bottom=0)
    
    plt.tight_layout()
    chart_path = os.path.join(output_dir, "equity_curves.png")
    plt.savefig(chart_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"âœ… æ·¨å€¼æ›²ç·šå·²å„²å­˜: {chart_path}")


def plot_trade_signals(ticker: str, features_df: pd.DataFrame, 
                       backtester: DynamicTrailingBacktester, output_dir: str):
    """ç¹ªè£½äº¤æ˜“è¨Šè™Ÿåœ–"""
    test_df = features_df[
        (features_df.index >= pd.Timestamp(VAL_START)) &
        (features_df.index <= pd.Timestamp(VAL_END))
    ]
    
    if len(test_df) == 0:
        return
    
    fig, ax = plt.subplots(figsize=(14, 6))
    
    ax.plot(test_df.index, test_df['Close'], label=f'{ticker} Close', color='black', linewidth=1)
    
    # è²·å…¥è¨Šè™Ÿ
    if backtester.buy_signals:
        buy_dates, buy_prices, _ = zip(*backtester.buy_signals)
        ax.scatter(buy_dates, buy_prices, marker='^', color='green', s=100, 
                   label='Buy Signal', zorder=5)
    
    # è³£å‡ºè¨Šè™Ÿ (ä¾åŸå› åˆ†è‰²)
    hard_stops = [(d, p) for d, p, r in backtester.sell_signals if 'Hard' in r]
    trailing_stops = [(d, p) for d, p, r in backtester.sell_signals if 'Trailing' in r]
    
    if hard_stops:
        dates, prices = zip(*hard_stops)
        ax.scatter(dates, prices, marker='v', color='red', s=100, label='Hard Stop', zorder=5)
    
    if trailing_stops:
        dates, prices = zip(*trailing_stops)
        ax.scatter(dates, prices, marker='v', color='orange', s=100, label='Trailing Stop', zorder=5)
    
    ax.set_title(f'{ticker} äº¤æ˜“è¨Šè™Ÿ (Confidence > {CONFIDENCE_THRESHOLD:.0%})', fontsize=13)
    ax.set_xlabel('Date', fontsize=11)
    ax.set_ylabel('Price ($)', fontsize=11)
    ax.legend(loc='upper left', fontsize=9)
    ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    chart_path = os.path.join(output_dir, f"trade_signals_{ticker}.png")
    plt.savefig(chart_path, dpi=150, bbox_inches='tight')
    plt.close()


# =============================================================================
# çµæœè¼¸å‡º
# =============================================================================
def save_report(all_results: list, benchmark: dict, output_dir: str):
    """å„²å­˜å›æ¸¬å ±å‘Š"""
    report_data = []
    
    for r in all_results:
        if r is None:
            continue
        report_data.append({
            'Ticker': r['ticker'],
            'æ¸¬è©¦èµ·å§‹': r['test_start'].strftime('%Y-%m-%d'),
            'æ¸¬è©¦çµæŸ': r['test_end'].strftime('%Y-%m-%d'),
            'åˆå§‹è³‡é‡‘': f"${r['initial_capital']:,.0f}",
            'æœ€çµ‚æ·¨å€¼': f"${r['final_value']:,.0f}",
            'ç¸½å ±é…¬ç‡': f"{r['total_return']:.1%}",
            'å¹´åŒ–å ±é…¬(CAGR)': f"{r['cagr']:.1%}",
            'å¤æ™®å€¼': f"{r['sharpe_ratio']:.2f}",
            'æœ€å¤§å›æ’¤(MDD)': f"{r['max_drawdown']:.1%}",
            'äº¤æ˜“æ¬¡æ•¸': r['total_trades'],
            'å‹ç‡': f"{r['win_rate']:.1%}",
            'å¹³å‡å ±é…¬': f"{r['avg_return']:.1%}",
            'å¹³å‡æŒæœ‰å¤©æ•¸': f"{r['avg_hold_days']:.1f}"
        })
    
    # åŠ å…¥ Benchmark
    if benchmark:
        report_data.append({
            'Ticker': '^IXIC (Benchmark)',
            'æ¸¬è©¦èµ·å§‹': VAL_START,
            'æ¸¬è©¦çµæŸ': VAL_END,
            'åˆå§‹è³‡é‡‘': f"${INITIAL_CAPITAL:,.0f}",
            'æœ€çµ‚æ·¨å€¼': f"${INITIAL_CAPITAL * (1 + benchmark['total_return']):,.0f}",
            'ç¸½å ±é…¬ç‡': f"{benchmark['total_return']:.1%}",
            'å¹´åŒ–å ±é…¬(CAGR)': f"{benchmark['cagr']:.1%}",
            'å¤æ™®å€¼': f"{benchmark['sharpe_ratio']:.2f}",
            'æœ€å¤§å›æ’¤(MDD)': f"{benchmark['max_drawdown']:.1%}",
            'äº¤æ˜“æ¬¡æ•¸': 'N/A',
            'å‹ç‡': 'N/A',
            'å¹³å‡å ±é…¬': 'N/A',
            'å¹³å‡æŒæœ‰å¤©æ•¸': 'N/A'
        })
    
    report_df = pd.DataFrame(report_data)
    csv_path = os.path.join(output_dir, "final_backtest_report.csv")
    report_df.to_csv(csv_path, index=False, encoding='utf-8-sig')
    print(f"âœ… å›æ¸¬å ±å‘Šå·²å„²å­˜: {csv_path}")
    
    return report_df


def print_summary(all_results: list, benchmark: dict):
    """å°å‡ºå›æ¸¬æ‘˜è¦"""
    print("\n" + "=" * 100)
    print("ğŸ“Š æ·±åº¦å›æ¸¬çµæœæ‘˜è¦")
    print(f"   æœŸé–“: {VAL_START} ~ {VAL_END}")
    print(f"   ä¿¡å¿ƒåº¦é–€æª»: > {CONFIDENCE_THRESHOLD:.0%}")
    print(f"   åœæ: {HARD_STOP_PCT:.0%} | åœåˆ©å•Ÿå‹•: +{TRAILING_ACTIVATION:.0%}")
    print("=" * 100)
    
    print(f"\n{'Ticker':>10} | {'ç¸½å ±é…¬':>10} | {'CAGR':>8} | {'Sharpe':>8} | {'MDD':>8} | {'äº¤æ˜“':>6} | {'å‹ç‡':>6}")
    print("-" * 80)
    
    for r in all_results:
        if r is None:
            continue
        print(f"{r['ticker']:>10} | {r['total_return']:>9.1%} | {r['cagr']:>7.1%} | {r['sharpe_ratio']:>7.2f} | {r['max_drawdown']:>7.1%} | {r['total_trades']:>6} | {r['win_rate']:>5.1%}")
    
    print("-" * 80)
    
    if benchmark:
        print(f"{'^IXIC B&H':>10} | {benchmark['total_return']:>9.1%} | {benchmark['cagr']:>7.1%} | {benchmark['sharpe_ratio']:>7.2f} | {benchmark['max_drawdown']:>7.1%} | {'N/A':>6} | {'N/A':>6}")
    
    print("=" * 100)


# =============================================================================
# ä¸»ç¨‹å¼
# =============================================================================
def main():
    print("=" * 70)
    print("  US Tech Stock - æ·±åº¦å›æ¸¬ (Dynamic Trailing Stop)")
    print(f"  æœŸé–“: {VAL_START} ~ {VAL_END}")
    print(f"  æ¨™çš„: {', '.join(TARGET_TICKERS)}")
    print("=" * 70)
    
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    
    # è¼‰å…¥ manifest
    print("\n[Step 1] è¼‰å…¥æ¨¡å‹...")
    manifest = load_model_manifest(MODELS_PATH)
    if manifest is None:
        print("âŒ ç„¡æ³•è¼‰å…¥ manifest")
        return
    
    # è¼‰å…¥åŸºæº–æŒ‡æ•¸
    print("\n[Step 2] è¼‰å…¥åŸºæº–æŒ‡æ•¸...")
    benchmark_df = load_or_update_local_csv(BENCHMARK)
    if benchmark_df is None:
        print("âŒ ç„¡æ³•è¼‰å…¥åŸºæº–æŒ‡æ•¸")
        return
    
    benchmark = calculate_benchmark(benchmark_df)
    
    # åŸ·è¡Œå›æ¸¬
    print("\n[Step 3] åŸ·è¡Œå›æ¸¬...")
    all_results = []
    all_backtesters = {}
    all_features = {}
    
    for ticker in TARGET_TICKERS:
        print(f"\nğŸ“ˆ {ticker}")
        print("-" * 40)
        
        model = load_ticker_model(ticker, manifest)
        if model is None:
            print(f"  âš ï¸ æ¨¡å‹è¼‰å…¥å¤±æ•—")
            all_results.append(None)
            continue
        print(f"  âœ… æ¨¡å‹è¼‰å…¥æˆåŠŸ")
        
        raw_df = load_or_update_local_csv(ticker)
        if raw_df is None:
            all_results.append(None)
            continue
        
        features_df = calculate_features(raw_df, benchmark_df, ticker, use_cache=True)
        all_features[ticker] = features_df
        
        backtester = DynamicTrailingBacktester(INITIAL_CAPITAL)
        result = backtester.run(ticker, model, features_df)
        all_results.append(result)
        all_backtesters[ticker] = backtester
        
        if result:
            print(f"  ğŸ“Š Return: {result['total_return']:.1%} | Trades: {result['total_trades']} | Win: {result['win_rate']:.1%}")
    
    # è¼¸å‡ºçµæœ
    print("\n[Step 4] è¼¸å‡ºçµæœ...")
    
    print_summary(all_results, benchmark)
    save_report(all_results, benchmark, OUTPUT_DIR)
    plot_equity_curves(all_results, benchmark, OUTPUT_DIR)
    
    # ç¹ªè£½å€‹è‚¡äº¤æ˜“è¨Šè™Ÿ
    for ticker in TARGET_TICKERS:
        if ticker in all_backtesters and ticker in all_features:
            plot_trade_signals(ticker, all_features[ticker], all_backtesters[ticker], OUTPUT_DIR)
    
    print("\n" + "=" * 70)
    print("  âœ… å›æ¸¬å®Œæˆï¼")
    print(f"  ğŸ“ çµæœå„²å­˜æ–¼: {OUTPUT_DIR}/")
    print("=" * 70)


if __name__ == "__main__":
    main()
