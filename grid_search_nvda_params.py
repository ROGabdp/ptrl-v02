#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
================================================================================
NVDA é¢¨éšªç®¡ç†åƒæ•¸ç¶²æ ¼æœç´¢
================================================================================
å° backtest_nvda_follow.py çš„é¢¨éšªç®¡ç†åƒæ•¸é€²è¡Œç¶²æ ¼æœç´¢ï¼Œæ‰¾å‡ºæœ€ä½³çµ„åˆã€‚

æ¸¬è©¦åƒæ•¸ï¼š
- HARD_STOP_PCT: ç¡¬æ€§åœææ¯”ä¾‹
- TRAILING_ACTIVATION: ç§»å‹•åœåˆ©å•Ÿå‹•é»
- CALLBACK_BASE: åŸºç¤å›æª”æ­¢ç›ˆ
- CALLBACK_HIGH: é«˜åˆ©æ½¤å›æª”æ­¢ç›ˆ

ä½œè€…ï¼šPhil Liang (Generated by Gemini)
æ—¥æœŸï¼š2026-01-18
================================================================================
"""

import os
import sys
import json
import itertools
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime
from tqdm import tqdm
import torch

if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

plt.rcParams['font.sans-serif'] = ['Microsoft JhengHei', 'SimHei', 'Arial Unicode MS']
plt.rcParams['axes.unicode_minus'] = False

from train_us_tech_buy_agent import (
    load_or_update_local_csv,
    calculate_features,
    BENCHMARK, FEATURE_COLS, MODELS_PATH
)

from stable_baselines3 import PPO

# å°å…¥å›æ¸¬å™¨
from backtest_nvda_follow import (
    TICKER, YEARLY_INJECTION, CONFIDENCE_HIGH, CONFIDENCE_LOW,
    BUY_RATIO_HIGH, BUY_RATIO_LOW,
    load_model_manifest, load_ticker_model, get_action_confidence,
    prepare_market_filter, check_entry_condition,
    calculate_nasdaq_benchmark
)


# =============================================================================
# ç¶²æ ¼æœç´¢åƒæ•¸ç¯„åœ
# =============================================================================
GRID_PARAMS = {
    'HARD_STOP_PCT': [-0.08],
    'TRAILING_ACTIVATION': [0.20],
    'HIGH_PROFIT_THR': [0.25],
    'CALLBACK_BASE': [0.08],
    'CALLBACK_HIGH': [0.16,0.17, 0.18, 0.19]  # å¯†æ¸¬ 18% å‘¨é‚Š
}

# å›æ¸¬æ—¥æœŸç¯„åœ
BACKTEST_START = "2017-10-16"
BACKTEST_END = "2023-10-15"

OUTPUT_DIR = "grid_search_results_nvda"


# =============================================================================
# ä¿®æ”¹ç‰ˆå›æ¸¬å™¨ (æ¥å—åƒæ•¸)
# =============================================================================
class ParameterizedBacktester:
    """å¯æ¥å—åƒæ•¸çš„å›æ¸¬å™¨"""
    
    def __init__(self, hard_stop: float, trailing_activation: float,
                 high_profit_thr: float, callback_base: float, callback_high: float,
                 yearly_injection: float = YEARLY_INJECTION):
        self.hard_stop_pct = hard_stop
        self.trailing_activation = trailing_activation
        self.high_profit_thr = high_profit_thr
        self.callback_base = callback_base
        self.callback_high = callback_high
        self.yearly_injection = yearly_injection
        
        self.capital_pool = 0.0
        self.positions = []
        self.trades = []
        self.equity_curve = []
        self.injection_log = []
    
    def run(self, model: PPO, features_df: pd.DataFrame, 
            benchmark_df: pd.DataFrame, start_date: str, end_date: str) -> dict:
        """åŸ·è¡Œå›æ¸¬"""
        test_df = prepare_market_filter(benchmark_df, features_df)
        test_df = test_df[
            (test_df.index >= pd.Timestamp(start_date)) &
            (test_df.index <= pd.Timestamp(end_date))
        ].copy()
        
        if len(test_df) == 0:
            return None
        
        dates = test_df.index.tolist()
        closes = test_df['Close'].values
        features = test_df[FEATURE_COLS].values.astype(np.float32)
        
        # åˆå§‹åŒ–
        self.capital_pool = self.yearly_injection
        self.injection_log.append({'date': dates[0], 'amount': self.yearly_injection})
        
        current_year = dates[0].year
        year_first_day_processed = {current_year: True}
        
        for i in range(len(test_df)):
            date = dates[i]
            price = closes[i]
            row = test_df.iloc[i]
            
            # å¹´åº¦æ³¨å…¥
            if date.year != current_year:
                current_year = date.year
                if current_year not in year_first_day_processed:
                    self.capital_pool += self.yearly_injection
                    self.injection_log.append({'date': date, 'amount': self.yearly_injection})
                    year_first_day_processed[current_year] = True
            
            # è¨ˆç®—æ·¨å€¼
            position_value = sum(p['shares'] * price for p in self.positions)
            current_value = self.capital_pool + position_value
            self.equity_curve.append({
                'date': date, 
                'value': current_value,
                'capital_pool': self.capital_pool,
                'position_value': position_value
            })
            
            # å‡ºå ´æª¢æŸ¥
            positions_to_remove = []
            for idx, pos in enumerate(self.positions):
                buy_price = pos['buy_price']
                current_return = price / buy_price - 1
                highest_return = pos['highest_price'] / buy_price - 1
                drawdown_from_high = (pos['highest_price'] - price) / pos['highest_price']
                
                if price > pos['highest_price']:
                    pos['highest_price'] = price
                
                sell_reason = None
                
                # ç¡¬æ€§åœæ
                if current_return <= self.hard_stop_pct:
                    sell_reason = "Hard Stop"
                # ç§»å‹•åœåˆ©
                elif highest_return >= self.trailing_activation:
                    cb_limit = self.callback_high if highest_return >= self.high_profit_thr else self.callback_base
                    if drawdown_from_high >= cb_limit:
                        sell_reason = "Trailing Stop"
                
                if sell_reason:
                    sell_value = pos['shares'] * price
                    profit = sell_value - pos['cost']
                    self.capital_pool += sell_value
                    
                    self.trades.append({
                        'buy_date': pos['buy_date'],
                        'buy_price': buy_price,
                        'sell_date': date,
                        'sell_price': price,
                        'return': current_return,
                        'profit': profit,
                        'hold_days': (date - pos['buy_date']).days,
                        'exit_reason': sell_reason
                    })
                    positions_to_remove.append(idx)
            
            for idx in sorted(positions_to_remove, reverse=True):
                self.positions.pop(idx)
            
            # é€²å ´æª¢æŸ¥
            obs = features[i]
            action, confidence = get_action_confidence(model, obs)
            
            if action == 1:
                allow_entry, entry_type = check_entry_condition(row)
                
                if allow_entry:
                    if confidence > CONFIDENCE_HIGH:
                        buy_ratio = BUY_RATIO_HIGH
                    elif confidence >= CONFIDENCE_LOW:
                        buy_ratio = BUY_RATIO_LOW
                    else:
                        buy_ratio = 0
                    
                    if buy_ratio > 0 and self.capital_pool > 0:
                        invest_amount = self.capital_pool * buy_ratio
                        
                        # è·³éç„¡æ³•è²·åˆ°1è‚¡çš„æƒ…æ³
                        if invest_amount < price:
                            continue
                        
                        shares = invest_amount / price
                        
                        if shares > 0:
                            cost = shares * price
                            self.capital_pool -= cost
                            
                            self.positions.append({
                                'shares': shares,
                                'buy_price': price,
                                'buy_date': date,
                                'cost': cost,
                                'highest_price': price
                            })
        
        return self._calculate_metrics(test_df)
    
    def _calculate_metrics(self, test_df: pd.DataFrame) -> dict:
        """è¨ˆç®—ç¸¾æ•ˆæŒ‡æ¨™"""
        if not self.equity_curve:
            return None
        
        equity_df = pd.DataFrame(self.equity_curve)
        equity_df['date'] = pd.to_datetime(equity_df['date'])
        equity_df.set_index('date', inplace=True)
        
        total_injected = sum(log['amount'] for log in self.injection_log)
        final_value = equity_df['value'].iloc[-1]
        total_return = (final_value - total_injected) / total_injected
        
        days = (equity_df.index[-1] - equity_df.index[0]).days
        years = days / 365.0
        cagr = (final_value / total_injected) ** (1 / years) - 1 if years > 0 else 0
        
        daily_returns = equity_df['value'].pct_change().dropna()
        if len(daily_returns) > 0 and daily_returns.std() > 0:
            sharpe = (daily_returns.mean() * 252 - 0.02) / (daily_returns.std() * np.sqrt(252))
        else:
            sharpe = 0
        
        rolling_max = equity_df['value'].cummax()
        drawdown = (equity_df['value'] - rolling_max) / rolling_max
        max_drawdown = drawdown.min()
        
        if self.trades:
            wins = sum(1 for t in self.trades if t['return'] > 0)
            win_rate = wins / len(self.trades)
        else:
            win_rate = 0
        
        return {
            'total_injected': total_injected,
            'final_value': final_value,
            'total_return': total_return,
            'cagr': cagr,
            'sharpe_ratio': sharpe,
            'max_drawdown': max_drawdown,
            'total_trades': len(self.trades),
            'win_rate': win_rate
        }


# =============================================================================
# ç¶²æ ¼æœç´¢åŸ·è¡Œ
# =============================================================================
def run_grid_search(model, features_df, benchmark_df):
    """åŸ·è¡Œç¶²æ ¼æœç´¢"""
    # ç”Ÿæˆæ‰€æœ‰åƒæ•¸çµ„åˆ
    param_names = list(GRID_PARAMS.keys())
    param_values = list(GRID_PARAMS.values())
    combinations = list(itertools.product(*param_values))
    
    print(f"\nç¸½å…±æ¸¬è©¦ {len(combinations)} çµ„åƒæ•¸çµ„åˆ")
    print(f"é ä¼°æ™‚é–“: ç´„ {len(combinations) * 0.5:.0f} åˆ†é˜\n")
    
    results = []
    
    for combo in tqdm(combinations, desc="Grid Search Progress"):
        params = dict(zip(param_names, combo))
        
        backtester = ParameterizedBacktester(
            hard_stop=params['HARD_STOP_PCT'],
            trailing_activation=params['TRAILING_ACTIVATION'],
            high_profit_thr=params['HIGH_PROFIT_THR'],
            callback_base=params['CALLBACK_BASE'],
            callback_high=params['CALLBACK_HIGH']
        )
        
        result = backtester.run(model, features_df, benchmark_df, 
                                BACKTEST_START, BACKTEST_END)
        
        if result:
            result.update(params)
            results.append(result)
    
    return pd.DataFrame(results)


# =============================================================================
# çµæœåˆ†æèˆ‡è¦–è¦ºåŒ–
# =============================================================================
def analyze_results(results_df: pd.DataFrame, output_dir: str):
    """åˆ†æä¸¦è¦–è¦ºåŒ–çµæœ"""
    
    # æ’åºä¸¦å„²å­˜
    results_sorted = results_df.sort_values('sharpe_ratio', ascending=False)
    csv_path = os.path.join(output_dir, "grid_search_results.csv")
    results_sorted.to_csv(csv_path, index=False, encoding='utf-8-sig')
    print(f"âœ… çµæœå·²å„²å­˜: {csv_path}")
    
    # é¡¯ç¤º Top 10
    print("\n" + "=" * 100)
    print("ğŸ“Š Top 10 åƒæ•¸çµ„åˆ (ä¾ Sharpe Ratio æ’åº)")
    print("=" * 100)
    
    display_cols = ['HARD_STOP_PCT', 'TRAILING_ACTIVATION', 'HIGH_PROFIT_THR',
                    'CALLBACK_BASE', 'CALLBACK_HIGH', 'total_return', 'sharpe_ratio', 'max_drawdown', 'win_rate']
    
    top_10 = results_sorted[display_cols].head(10)
    
    for idx, row in top_10.iterrows():
        print(f"\nRank {top_10.index.get_loc(idx) + 1}:")
        print(f"  Hard Stop: {row['HARD_STOP_PCT']:.1%} | Trail Act: {row['TRAILING_ACTIVATION']:.1%} | High Profit: {row['HIGH_PROFIT_THR']:.1%}")
        print(f"  CB Base: {row['CALLBACK_BASE']:.1%} | CB High: {row['CALLBACK_HIGH']:.1%}")
        print(f"  â†’ Return: {row['total_return']:.1%} | Sharpe: {row['sharpe_ratio']:.2f} | MDD: {row['max_drawdown']:.1%}")
    
    print("=" * 100)
    
    # è¦–è¦ºåŒ–
    plot_heatmaps(results_df, output_dir)
    plot_parameter_impact(results_df, output_dir)
    plot_scatter_matrix(results_df, output_dir)


def plot_heatmaps(results_df: pd.DataFrame, output_dir: str):
    """ç¹ªè£½ç†±åŠ›åœ– (2D åƒæ•¸çµ„åˆ)"""
    fig, axes = plt.subplots(2, 3, figsize=(18, 12))
    
    param_pairs = [
        ('HARD_STOP_PCT', 'TRAILING_ACTIVATION'),
        ('TRAILING_ACTIVATION', 'HIGH_PROFIT_THR'),
        ('HIGH_PROFIT_THR', 'CALLBACK_BASE'),
        ('HIGH_PROFIT_THR', 'CALLBACK_HIGH'),
        ('TRAILING_ACTIVATION', 'CALLBACK_BASE'),
        ('CALLBACK_BASE', 'CALLBACK_HIGH')
    ]
    
    for idx, (param1, param2) in enumerate(param_pairs):
        ax = axes[idx // 3, idx % 3]
        
        # å–è©²çµ„åˆçš„å¹³å‡ Sharpe
        pivot = results_df.groupby([param1, param2])['sharpe_ratio'].mean().unstack()
        
        sns.heatmap(pivot, annot=True, fmt='.2f', cmap='RdYlGn', ax=ax, 
                    cbar_kws={'label': 'Sharpe Ratio'})
        ax.set_title(f'{param1} vs {param2}')
        ax.set_xlabel(param2)
        ax.set_ylabel(param1)
    
    plt.tight_layout()
    heatmap_path = os.path.join(output_dir, "parameter_heatmaps.png")
    plt.savefig(heatmap_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"âœ… ç†±åŠ›åœ–å·²å„²å­˜: {heatmap_path}")


def plot_parameter_impact(results_df: pd.DataFrame, output_dir: str):
    """ç¹ªè£½å–®åƒæ•¸å½±éŸ¿åœ–"""
    fig, axes = plt.subplots(2, 3, figsize=(18, 10))
    
    params = ['HARD_STOP_PCT', 'TRAILING_ACTIVATION', 'HIGH_PROFIT_THR', 'CALLBACK_BASE', 'CALLBACK_HIGH']
    
    for idx, param in enumerate(params):
        ax = axes[idx // 3, idx % 3]
        
        grouped = results_df.groupby(param).agg({
            'sharpe_ratio': 'mean',
            'total_return': 'mean',
            'max_drawdown': 'mean'
        })
        
        ax2 = ax.twinx()
        
        grouped['sharpe_ratio'].plot(ax=ax, marker='o', color='blue', label='Sharpe', linewidth=2)
        grouped['total_return'].plot(ax=ax2, marker='s', color='green', label='Return', linewidth=2)
        
        ax.set_xlabel(param)
        ax.set_ylabel('Sharpe Ratio', color='blue')
        ax2.set_ylabel('Total Return', color='green')
        ax.tick_params(axis='y', labelcolor='blue')
        ax2.tick_params(axis='y', labelcolor='green')
        ax.set_title(f'{param} å½±éŸ¿åˆ†æ')
        ax.grid(True, alpha=0.3)
        
        # åˆä½µåœ–ä¾‹
        lines1, labels1 = ax.get_legend_handles_labels()
        lines2, labels2 = ax2.get_legend_handles_labels()
        ax.legend(lines1 + lines2, labels1 + labels2, loc='upper left')
    
    plt.tight_layout()
    impact_path = os.path.join(output_dir, "parameter_impact.png")
    plt.savefig(impact_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"âœ… åƒæ•¸å½±éŸ¿åœ–å·²å„²å­˜: {impact_path}")


def plot_scatter_matrix(results_df: pd.DataFrame, output_dir: str):
    """ç¹ªè£½æ•£é»çŸ©é™£ (Return vs Sharpe vs MDD)"""
    fig, axes = plt.subplots(1, 3, figsize=(18, 5))
    
    # Sharpe vs Return
    ax1 = axes[0]
    scatter1 = ax1.scatter(results_df['sharpe_ratio'], results_df['total_return'],
                          c=results_df['max_drawdown'], cmap='RdYlGn_r', 
                          s=50, alpha=0.6)
    ax1.set_xlabel('Sharpe Ratio')
    ax1.set_ylabel('Total Return')
    ax1.set_title('Sharpe vs Return (è‰²=MDD)')
    plt.colorbar(scatter1, ax=ax1, label='Max Drawdown')
    ax1.grid(True, alpha=0.3)
    
    # Sharpe vs MDD
    ax2 = axes[1]
    scatter2 = ax2.scatter(results_df['sharpe_ratio'], results_df['max_drawdown'],
                          c=results_df['total_return'], cmap='RdYlGn', 
                          s=50, alpha=0.6)
    ax2.set_xlabel('Sharpe Ratio')
    ax2.set_ylabel('Max Drawdown')
    ax2.set_title('Sharpe vs MDD (è‰²=Return)')
    plt.colorbar(scatter2, ax=ax2, label='Total Return')
    ax2.grid(True, alpha=0.3)
    
    # Return vs MDD
    ax3 = axes[2]
    scatter3 = ax3.scatter(results_df['total_return'], results_df['max_drawdown'],
                          c=results_df['sharpe_ratio'], cmap='RdYlGn', 
                          s=50, alpha=0.6)
    ax3.set_xlabel('Total Return')
    ax3.set_ylabel('Max Drawdown')
    ax3.set_title('Return vs MDD (è‰²=Sharpe)')
    plt.colorbar(scatter3, ax=ax3, label='Sharpe Ratio')
    ax3.grid(True, alpha=0.3)
    
    plt.tight_layout()
    scatter_path = os.path.join(output_dir, "performance_scatter.png")
    plt.savefig(scatter_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"âœ… æ•£é»åœ–å·²å„²å­˜: {scatter_path}")


# =============================================================================
# ä¸»ç¨‹å¼
# =============================================================================
def main():
    print("=" * 70)
    print("  NVDA é¢¨éšªç®¡ç†åƒæ•¸ç¶²æ ¼æœç´¢")
    print(f"  æœŸé–“: {BACKTEST_START} ~ {BACKTEST_END}")
    print("=" * 70)
    print("\næ¸¬è©¦åƒæ•¸ç¯„åœ:")
    for param, values in GRID_PARAMS.items():
        print(f"  {param}: {values}")
    print("=" * 70)
    
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    
    # è¼‰å…¥æ¨¡å‹
    print("\n[Step 1] è¼‰å…¥æ¨¡å‹...")
    manifest = load_model_manifest(MODELS_PATH)
    if manifest is None:
        print("âŒ ç„¡æ³•è¼‰å…¥ manifest")
        return
    
    model = load_ticker_model(TICKER, manifest)
    if model is None:
        print(f"âŒ ç„¡æ³•è¼‰å…¥ {TICKER} æ¨¡å‹")
        return
    print(f"âœ… {TICKER} æ¨¡å‹è¼‰å…¥æˆåŠŸ")
    
    # è¼‰å…¥æ•¸æ“š
    print("\n[Step 2] è¼‰å…¥æ•¸æ“š...")
    benchmark_df = load_or_update_local_csv(BENCHMARK)
    if benchmark_df is None:
        print("âŒ ç„¡æ³•è¼‰å…¥åŸºæº–æŒ‡æ•¸")
        return
    
    raw_df = load_or_update_local_csv(TICKER)
    if raw_df is None:
        print(f"âŒ ç„¡æ³•è¼‰å…¥ {TICKER} æ•¸æ“š")
        return
    
    features_df = calculate_features(raw_df, benchmark_df, TICKER, use_cache=True)
    print(f"âœ… æ•¸æ“šè¼‰å…¥å®Œæˆ")
    
    # åŸ·è¡Œç¶²æ ¼æœç´¢
    print("\n[Step 3] åŸ·è¡Œç¶²æ ¼æœç´¢...")
    results_df = run_grid_search(model, features_df, benchmark_df)
    
    # åˆ†æçµæœ
    print("\n[Step 4] åˆ†æçµæœ...")
    analyze_results(results_df, OUTPUT_DIR)
    
    print("\n" + "=" * 70)
    print("  âœ… ç¶²æ ¼æœç´¢å®Œæˆï¼")
    print(f"  ğŸ“ çµæœå„²å­˜æ–¼: {OUTPUT_DIR}/")
    print("=" * 70)


if __name__ == "__main__":
    main()
