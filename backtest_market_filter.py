#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
================================================================================
US Tech Stock - æ·±åº¦å›æ¸¬ (å¸‚å ´æ¿¾ç¶²ç‰ˆæœ¬)
================================================================================
å¼•å…¥ã€Œ120 æ—¥å‡ç·šã€èˆ‡ã€Œ20 æ—¥å”å…¶å®‰é€šé“ã€ä½œç‚ºå¸‚å ´æ¿¾ç¶²ï¼Œå„ªåŒ– MDD èˆ‡ Sharpeã€‚

å¸‚å ´æ¿¾ç¶²é‚è¼¯:
- æ¢ä»¶ 1 (å¤šé ­å¸‚å ´): Nasdaq > 120MA â†’ å‡†è¨±è²·å…¥
- æ¢ä»¶ 2 (é€†å‹¢çªç ´): Nasdaq <= 120MA ä¸” å€‹è‚¡ > DC20_High â†’ å‡†è¨±è²·å…¥
- å…¶é¤˜æƒ…æ³: å³ä½¿ Agent ç™¼å‡ºä¿¡è™Ÿä¹Ÿä¿æŒç©ºæ‰‹

å›æ¸¬è¨­å®š:
- æœŸé–“: 2017-10-16 ~ 2023-10-15
- ä¿¡å¿ƒåº¦é–€æª»: > 90%
- åœæåœåˆ©: -8% / 8% / 9% (æ•æ„Ÿåº¦åˆ†æå»ºè­°)

ä½œè€…ï¼šPhil Liang (Generated by Gemini)
æ—¥æœŸï¼š2026-01-18
================================================================================
"""

import os
import sys
import json
import argparse
import torch
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime
from tqdm import tqdm

if sys.platform == 'win32':
    sys.stdout.reconfigure(encoding='utf-8')

plt.rcParams['font.sans-serif'] = ['Microsoft JhengHei', 'SimHei', 'Arial Unicode MS']
plt.rcParams['axes.unicode_minus'] = False

from train_us_tech_buy_agent import (
    load_or_update_local_csv,
    calculate_features,
    BENCHMARK, FEATURE_COLS, VAL_RANGE, MODELS_PATH
)

from stable_baselines3 import PPO


# =============================================================================
# å›æ¸¬åƒæ•¸
# =============================================================================
TARGET_TICKERS = ["PLTR", "NVDA", "TSLA", "NFLX"]
DEFAULT_START, DEFAULT_END = VAL_RANGE
INITIAL_CAPITAL = 1_000_000

# é€²å ´æ¢ä»¶
CONFIDENCE_THRESHOLD = 0.90

# é¢¨éšªç®¡ç†åƒæ•¸ (æ•æ„Ÿåº¦åˆ†æå»ºè­°)
HARD_STOP_PCT = -0.08
TRAILING_ACTIVATION = 0.15
HIGH_PROFIT_THR = 0.25
CALLBACK_BASE = 0.08
CALLBACK_HIGH = 0.09

OUTPUT_DIR = "backtest_results_filtered"

# å…¨åŸŸè®Šæ•¸ (ç”±å‘½ä»¤åˆ—åƒæ•¸è¨­å®š)
BACKTEST_START = DEFAULT_START
BACKTEST_END = DEFAULT_END


# =============================================================================
# æ¨¡å‹è¼‰å…¥
# =============================================================================
def load_model_manifest(models_path: str) -> dict:
    manifest_path = os.path.join(models_path, "model_manifest.json")
    if not os.path.exists(manifest_path):
        return None
    with open(manifest_path, 'r', encoding='utf-8') as f:
        return json.load(f)


def load_ticker_model(ticker: str, manifest: dict) -> PPO:
    if ticker not in manifest.get("tickers", {}):
        return None
    model_path = manifest["tickers"][ticker]["model_path"]
    if not os.path.exists(model_path):
        return None
    return PPO.load(model_path, device="cpu")


def get_action_confidence(model: PPO, obs: np.ndarray) -> tuple:
    obs_tensor = torch.as_tensor(obs.reshape(1, -1), dtype=torch.float32)
    with torch.no_grad():
        distribution = model.policy.get_distribution(obs_tensor)
        probs = distribution.distribution.probs.numpy()[0]
        action, _ = model.predict(obs, deterministic=True)
        return int(action), float(probs[1])


# =============================================================================
# å¸‚å ´æ¿¾ç¶²è¨ˆç®—
# =============================================================================
def prepare_market_filter(benchmark_df: pd.DataFrame, ticker_df: pd.DataFrame) -> pd.DataFrame:
    """
    è¨ˆç®—å¸‚å ´æ¿¾ç¶²æŒ‡æ¨™
    
    Args:
        benchmark_df: Nasdaq (^IXIC) è³‡æ–™
        ticker_df: å€‹è‚¡è³‡æ–™
    
    Returns:
        pd.DataFrame: åŒ…å«æ¿¾ç¶²æŒ‡æ¨™çš„åˆä½µè³‡æ–™
    """
    # Nasdaq 120MA
    benchmark_df = benchmark_df.copy()
    benchmark_df['Nasdaq_120MA'] = benchmark_df['Close'].rolling(120).mean()
    benchmark_df['Nasdaq_Above_120MA'] = benchmark_df['Close'] > benchmark_df['Nasdaq_120MA']
    
    # å€‹è‚¡ 20 æ—¥å”å…¶å®‰é€šé“
    ticker_df = ticker_df.copy()
    ticker_df['DC20_High'] = ticker_df['High'].rolling(20).max().shift(1)  # å‰ä¸€å¤©çš„ 20 æ—¥æœ€é«˜
    ticker_df['Ticker_Above_DC20'] = ticker_df['Close'] > ticker_df['DC20_High']
    
    # åˆä½µ Nasdaq æŒ‡æ¨™åˆ°å€‹è‚¡è³‡æ–™
    nasdaq_cols = ['Nasdaq_120MA', 'Nasdaq_Above_120MA']
    for col in nasdaq_cols:
        ticker_df[col] = benchmark_df[col].reindex(ticker_df.index).ffill()
    
    return ticker_df


def check_entry_condition(row: pd.Series) -> tuple:
    """
    æª¢æŸ¥é€²å ´æ¢ä»¶
    
    Returns:
        tuple: (allow_entry: bool, entry_type: str)
            - entry_type: "bull_market", "breakout", "blocked"
    """
    nasdaq_above_ma = row.get('Nasdaq_Above_120MA', False)
    ticker_above_dc = row.get('Ticker_Above_DC20', False)
    
    # æ¢ä»¶ 1: å¤šé ­å¸‚å ´
    if nasdaq_above_ma:
        return True, "bull_market"
    
    # æ¢ä»¶ 2: é€†å‹¢å¼·å‹¢çªç ´
    if not nasdaq_above_ma and ticker_above_dc:
        return True, "breakout"
    
    # å…¶é¤˜æƒ…æ³: ä¿æŒç©ºæ‰‹
    return False, "blocked"


# =============================================================================
# å›æ¸¬å¼•æ“ (å¸‚å ´æ¿¾ç¶²ç‰ˆæœ¬)
# =============================================================================
class FilteredBacktester:
    """å¸‚å ´æ¿¾ç¶²å›æ¸¬å™¨"""
    
    def __init__(self, initial_capital: float = INITIAL_CAPITAL, use_filter: bool = True):
        self.initial_capital = initial_capital
        self.use_filter = use_filter
        self.trades = []
        self.equity_curve = []
        self.buy_signals = []  # (date, price, entry_type, confidence)
        self.sell_signals = []
        self.blocked_signals = []  # Agent ç™¼å‡ºä¿¡è™Ÿä½†è¢«æ¿¾ç¶²æ“‹ä½
    
    def run(self, ticker: str, model: PPO, features_df: pd.DataFrame, 
            benchmark_df: pd.DataFrame, start_date: str = None, end_date: str = None) -> dict:
        """åŸ·è¡Œå›æ¸¬"""
        start_date = start_date or BACKTEST_START
        end_date = end_date or BACKTEST_END
        
        # æº–å‚™å¸‚å ´æ¿¾ç¶²
        test_df = prepare_market_filter(benchmark_df, features_df)
        
        # éæ¿¾æ¸¬è©¦æœŸé–“
        test_df = test_df[
            (test_df.index >= pd.Timestamp(start_date)) &
            (test_df.index <= pd.Timestamp(end_date))
        ].copy()
        
        if len(test_df) == 0:
            return None
        
        capital = self.initial_capital
        position = None
        
        dates = test_df.index.tolist()
        closes = test_df['Close'].values
        features = test_df[FEATURE_COLS].values.astype(np.float32)
        
        for i in tqdm(range(len(test_df)), desc=f"  Backtesting {ticker}", leave=False):
            date = dates[i]
            price = closes[i]
            row = test_df.iloc[i]
            
            # è¨˜éŒ„æ·¨å€¼
            if position:
                current_value = capital + position['shares'] * price
            else:
                current_value = capital
            self.equity_curve.append({'date': date, 'value': current_value})
            
            # =====================================================================
            # æŒæœ‰ä¸­ï¼šæª¢æŸ¥å‡ºå ´
            # =====================================================================
            if position is not None:
                buy_price = position['buy_price']
                current_return = price / buy_price - 1
                highest_return = position['highest_price'] / buy_price - 1
                drawdown_from_high = (position['highest_price'] - price) / position['highest_price']
                
                if price > position['highest_price']:
                    position['highest_price'] = price
                
                sell_reason = None
                
                # ç¡¬æ€§åœæ
                if current_return <= HARD_STOP_PCT:
                    sell_reason = "Hard Stop"
                # ç§»å‹•åœåˆ©
                elif highest_return >= TRAILING_ACTIVATION:
                    if highest_return >= HIGH_PROFIT_THR:
                        cb_limit = CALLBACK_HIGH
                    else:
                        cb_limit = CALLBACK_BASE
                    
                    if drawdown_from_high >= cb_limit:
                        sell_reason = f"Trailing Stop"
                
                if sell_reason:
                    sell_value = position['shares'] * price
                    profit = sell_value - position['shares'] * buy_price
                    capital += sell_value
                    
                    self.trades.append({
                        'ticker': ticker,
                        'buy_date': position['buy_date'],
                        'buy_price': buy_price,
                        'sell_date': date,
                        'sell_price': price,
                        'return': current_return,
                        'profit': profit,
                        'hold_days': i - position['buy_idx'],
                        'exit_reason': sell_reason,
                        'entry_type': position['entry_type']
                    })
                    self.sell_signals.append((date, price, sell_reason))
                    position = None
            
            # =====================================================================
            # ç©ºæ‰‹ï¼šæª¢æŸ¥é€²å ´
            # =====================================================================
            elif position is None:
                obs = features[i]
                action, confidence = get_action_confidence(model, obs)
                
                # Agent ç™¼å‡ºè²·å…¥ä¿¡è™Ÿ
                if action == 1 and confidence > CONFIDENCE_THRESHOLD:
                    # æª¢æŸ¥å¸‚å ´æ¿¾ç¶²
                    if self.use_filter:
                        allow_entry, entry_type = check_entry_condition(row)
                    else:
                        allow_entry, entry_type = True, "no_filter"
                    
                    if allow_entry:
                        invest_amount = capital * 0.95
                        shares = int(invest_amount / price)
                        
                        if shares > 0:
                            cost = shares * price
                            capital -= cost
                            
                            position = {
                                'shares': shares,
                                'buy_price': price,
                                'buy_date': date,
                                'buy_idx': i,
                                'highest_price': price,
                                'confidence': confidence,
                                'entry_type': entry_type
                            }
                            self.buy_signals.append((date, price, entry_type, confidence))
                    else:
                        self.blocked_signals.append((date, price, confidence))
        
        # å¼·åˆ¶å¹³å€‰
        if position is not None:
            final_price = closes[-1]
            sell_value = position['shares'] * final_price
            capital += sell_value
            current_return = final_price / position['buy_price'] - 1
            
            self.trades.append({
                'ticker': ticker,
                'buy_date': position['buy_date'],
                'buy_price': position['buy_price'],
                'sell_date': dates[-1],
                'sell_price': final_price,
                'return': current_return,
                'hold_days': len(test_df) - position['buy_idx'],
                'exit_reason': 'End of Test',
                'entry_type': position['entry_type']
            })
        
        return self._calculate_metrics(test_df, ticker)
    
    def _calculate_metrics(self, test_df: pd.DataFrame, ticker: str) -> dict:
        """è¨ˆç®—ç¸¾æ•ˆæŒ‡æ¨™"""
        if not self.equity_curve:
            return None
        
        equity_df = pd.DataFrame(self.equity_curve)
        equity_df['date'] = pd.to_datetime(equity_df['date'])
        equity_df.set_index('date', inplace=True)
        
        initial = self.initial_capital
        final = equity_df['value'].iloc[-1]
        total_return = (final - initial) / initial
        
        days = (equity_df.index[-1] - equity_df.index[0]).days
        years = days / 365.0
        cagr = (1 + total_return) ** (1 / years) - 1 if years > 0 else 0
        
        daily_returns = equity_df['value'].pct_change().dropna()
        if len(daily_returns) > 0 and daily_returns.std() > 0:
            sharpe = (daily_returns.mean() * 252 - 0.02) / (daily_returns.std() * np.sqrt(252))
        else:
            sharpe = 0
        
        rolling_max = equity_df['value'].cummax()
        drawdown = (equity_df['value'] - rolling_max) / rolling_max
        max_drawdown = drawdown.min()
        
        if self.trades:
            wins = sum(1 for t in self.trades if t['return'] > 0)
            win_rate = wins / len(self.trades)
        else:
            win_rate = 0
        
        # çµ±è¨ˆé€²å ´é¡å‹
        bull_entries = sum(1 for d, p, t, c in self.buy_signals if t == 'bull_market')
        breakout_entries = sum(1 for d, p, t, c in self.buy_signals if t == 'breakout')
        
        return {
            'ticker': ticker,
            'initial_capital': initial,
            'final_value': final,
            'total_return': total_return,
            'cagr': cagr,
            'sharpe_ratio': sharpe,
            'max_drawdown': max_drawdown,
            'total_trades': len(self.trades),
            'win_rate': win_rate,
            'bull_entries': bull_entries,
            'breakout_entries': breakout_entries,
            'blocked_signals': len(self.blocked_signals),
            'equity_df': equity_df,
            'test_start': test_df.index[0],
            'test_end': test_df.index[-1]
        }


# =============================================================================
# Benchmark
# =============================================================================
def calculate_benchmark(benchmark_df: pd.DataFrame, start_date: str = None, end_date: str = None) -> dict:
    start_date = start_date or BACKTEST_START
    end_date = end_date or BACKTEST_END
    
    test_df = benchmark_df[
        (benchmark_df.index >= pd.Timestamp(start_date)) &
        (benchmark_df.index <= pd.Timestamp(end_date))
    ]
    
    if len(test_df) == 0:
        return None
    
    initial_price = test_df['Close'].iloc[0]
    final_price = test_df['Close'].iloc[-1]
    total_return = (final_price - initial_price) / initial_price
    
    days = (test_df.index[-1] - test_df.index[0]).days
    years = days / 365.0
    cagr = (1 + total_return) ** (1 / years) - 1 if years > 0 else 0
    
    equity = test_df['Close'] / initial_price * INITIAL_CAPITAL
    rolling_max = equity.cummax()
    drawdown = (equity - rolling_max) / rolling_max
    max_drawdown = drawdown.min()
    
    daily_returns = test_df['Close'].pct_change().dropna()
    if len(daily_returns) > 0 and daily_returns.std() > 0:
        sharpe = (daily_returns.mean() * 252 - 0.02) / (daily_returns.std() * np.sqrt(252))
    else:
        sharpe = 0
    
    return {
        'ticker': '^IXIC (Benchmark)',
        'total_return': total_return,
        'cagr': cagr,
        'sharpe_ratio': sharpe,
        'max_drawdown': max_drawdown,
        'equity': equity
    }


# =============================================================================
# è¦–è¦ºåŒ–
# =============================================================================
def plot_equity_curves(filtered_results: list, unfiltered_results: list, 
                       benchmark: dict, output_dir: str):
    """ç¹ªè£½æ·¨å€¼æ›²ç·šå°æ¯”"""
    fig, ax = plt.subplots(figsize=(14, 8))
    
    colors = {'PLTR': '#E91E63', 'NVDA': '#4CAF50', 'TSLA': '#2196F3', 'NFLX': '#FF9800'}
    
    # ç¹ªè£½æ¿¾ç¶²ç‰ˆæœ¬ (å¯¦ç·š)
    for r in filtered_results:
        if r is None:
            continue
        equity = r['equity_df']['value']
        ax.plot(equity.index, equity.values, 
                label=f"{r['ticker']} Filtered ({r['total_return']:.0%})",
                linewidth=2, color=colors.get(r['ticker'], 'blue'))
    
    # ç¹ªè£½ç„¡æ¿¾ç¶²ç‰ˆæœ¬ (è™›ç·š)
    for r in unfiltered_results:
        if r is None:
            continue
        equity = r['equity_df']['value']
        ax.plot(equity.index, equity.values, 
                label=f"{r['ticker']} No Filter ({r['total_return']:.0%})",
                linewidth=1.5, linestyle='--', color=colors.get(r['ticker'], 'blue'), alpha=0.6)
    
    # Benchmark
    if benchmark:
        ax.plot(benchmark['equity'].index, benchmark['equity'].values, 
                label=f"^IXIC B&H ({benchmark['total_return']:.0%})",
                linewidth=2, linestyle=':', color='gray')
    
    ax.axhline(y=INITIAL_CAPITAL, color='black', linestyle=':', alpha=0.3)
    
    ax.set_title(f'ç´¯ç©æ·¨å€¼æ›²ç·šå°æ¯” (120MA + DC20 æ¿¾ç¶²)\n{BACKTEST_START} ~ {BACKTEST_END}', fontsize=14)
    ax.set_xlabel('Date')
    ax.set_ylabel('Portfolio Value ($)')
    ax.legend(loc='upper left', fontsize=9)
    ax.grid(True, alpha=0.3)
    ax.set_ylim(bottom=0)
    
    plt.tight_layout()
    chart_path = os.path.join(output_dir, "equity_curves_comparison.png")
    plt.savefig(chart_path, dpi=150, bbox_inches='tight')
    plt.close()
    print(f"âœ… æ·¨å€¼æ›²ç·šå·²å„²å­˜: {chart_path}")


def plot_trade_signals_filtered(ticker: str, features_df: pd.DataFrame, 
                                benchmark_df: pd.DataFrame,
                                backtester: FilteredBacktester, output_dir: str):
    """ç¹ªè£½äº¤æ˜“è¨Šè™Ÿåœ– (å€åˆ†é€²å ´é¡å‹)"""
    test_df = prepare_market_filter(benchmark_df, features_df)
    test_df = test_df[
        (test_df.index >= pd.Timestamp(BACKTEST_START)) &
        (test_df.index <= pd.Timestamp(BACKTEST_END))
    ]
    
    if len(test_df) == 0:
        return
    
    fig, axes = plt.subplots(2, 1, figsize=(14, 10), height_ratios=[3, 1])
    
    # å­åœ– 1: åƒ¹æ ¼èˆ‡äº¤æ˜“è¨Šè™Ÿ
    ax1 = axes[0]
    ax1.plot(test_df.index, test_df['Close'], label=f'{ticker} Close', color='black', linewidth=1)
    ax1.plot(test_df.index, test_df['DC20_High'], label='DC20 High', color='blue', 
             linewidth=0.8, linestyle='--', alpha=0.5)
    
    # è²·å…¥è¨Šè™Ÿ (ä¾é¡å‹åˆ†è‰²)
    bull_buys = [(d, p) for d, p, t, c in backtester.buy_signals if t == 'bull_market']
    breakout_buys = [(d, p) for d, p, t, c in backtester.buy_signals if t == 'breakout']
    
    if bull_buys:
        dates, prices = zip(*bull_buys)
        ax1.scatter(dates, prices, marker='^', color='green', s=100, 
                    label=f'Bull Market Entry ({len(bull_buys)})', zorder=5)
    
    if breakout_buys:
        dates, prices = zip(*breakout_buys)
        ax1.scatter(dates, prices, marker='*', color='gold', s=150, edgecolors='black',
                    label=f'Breakout Entry ({len(breakout_buys)})', zorder=6)
    
    # è¢«æ¿¾ç¶²æ“‹ä½çš„è¨Šè™Ÿ
    if backtester.blocked_signals:
        dates, prices, _ = zip(*backtester.blocked_signals)
        ax1.scatter(dates, prices, marker='x', color='red', s=50, alpha=0.5,
                    label=f'Blocked ({len(backtester.blocked_signals)})', zorder=4)
    
    # è³£å‡ºè¨Šè™Ÿ
    if backtester.sell_signals:
        dates, prices, _ = zip(*backtester.sell_signals)
        ax1.scatter(dates, prices, marker='v', color='red', s=80, label='Sell', zorder=5)
    
    ax1.set_title(f'{ticker} - äº¤æ˜“è¨Šè™Ÿ (120MA + DC20 æ¿¾ç¶²)', fontsize=13)
    ax1.set_ylabel('Price ($)')
    ax1.legend(loc='upper left', fontsize=9)
    ax1.grid(True, alpha=0.3)
    
    # å­åœ– 2: Nasdaq 120MA ç‹€æ…‹
    ax2 = axes[1]
    nasdaq_close = benchmark_df['Close'].reindex(test_df.index).ffill()
    nasdaq_ma = test_df['Nasdaq_120MA']
    
    ax2.plot(test_df.index, nasdaq_close, label='Nasdaq', color='purple', linewidth=1)
    ax2.plot(test_df.index, nasdaq_ma, label='120MA', color='orange', linewidth=1.5)
    ax2.fill_between(test_df.index, nasdaq_close, nasdaq_ma, 
                     where=nasdaq_close > nasdaq_ma, alpha=0.3, color='green', label='Bull')
    ax2.fill_between(test_df.index, nasdaq_close, nasdaq_ma, 
                     where=nasdaq_close <= nasdaq_ma, alpha=0.3, color='red', label='Bear')
    
    ax2.set_ylabel('Nasdaq')
    ax2.set_xlabel('Date')
    ax2.legend(loc='upper left', fontsize=9)
    ax2.grid(True, alpha=0.3)
    
    plt.tight_layout()
    chart_path = os.path.join(output_dir, f"trade_signals_filtered_{ticker}.png")
    plt.savefig(chart_path, dpi=150, bbox_inches='tight')
    plt.close()


# =============================================================================
# çµæœè¼¸å‡º
# =============================================================================
def save_comparison_report(filtered: list, unfiltered: list, benchmark: dict, output_dir: str):
    """å„²å­˜å°æ¯”å ±å‘Š"""
    report_data = []
    
    for f, u in zip(filtered, unfiltered):
        if f is None:
            continue
        
        ticker = f['ticker']
        
        # Filtered
        report_data.append({
            'Ticker': ticker,
            'Version': 'Filtered',
            'Total_Return': f"{f['total_return']:.1%}",
            'CAGR': f"{f['cagr']:.1%}",
            'Sharpe': f"{f['sharpe_ratio']:.2f}",
            'MDD': f"{f['max_drawdown']:.1%}",
            'Trades': f['total_trades'],
            'Win_Rate': f"{f['win_rate']:.1%}",
            'Bull_Entries': f['bull_entries'],
            'Breakout_Entries': f['breakout_entries'],
            'Blocked': f['blocked_signals']
        })
        
        # Unfiltered
        if u:
            report_data.append({
                'Ticker': ticker,
                'Version': 'No Filter',
                'Total_Return': f"{u['total_return']:.1%}",
                'CAGR': f"{u['cagr']:.1%}",
                'Sharpe': f"{u['sharpe_ratio']:.2f}",
                'MDD': f"{u['max_drawdown']:.1%}",
                'Trades': u['total_trades'],
                'Win_Rate': f"{u['win_rate']:.1%}",
                'Bull_Entries': 'N/A',
                'Breakout_Entries': 'N/A',
                'Blocked': 0
            })
    
    # Benchmark
    if benchmark:
        report_data.append({
            'Ticker': '^IXIC',
            'Version': 'Buy & Hold',
            'Total_Return': f"{benchmark['total_return']:.1%}",
            'CAGR': f"{benchmark['cagr']:.1%}",
            'Sharpe': f"{benchmark['sharpe_ratio']:.2f}",
            'MDD': f"{benchmark['max_drawdown']:.1%}",
            'Trades': 'N/A',
            'Win_Rate': 'N/A',
            'Bull_Entries': 'N/A',
            'Breakout_Entries': 'N/A',
            'Blocked': 'N/A'
        })
    
    report_df = pd.DataFrame(report_data)
    csv_path = os.path.join(output_dir, "filter_comparison_report.csv")
    report_df.to_csv(csv_path, index=False, encoding='utf-8-sig')
    print(f"âœ… å°æ¯”å ±å‘Šå·²å„²å­˜: {csv_path}")
    
    return report_df


def print_comparison_summary(filtered: list, unfiltered: list, benchmark: dict):
    """å°å‡ºå°æ¯”æ‘˜è¦"""
    print("\n" + "=" * 110)
    print("ğŸ“Š å¸‚å ´æ¿¾ç¶²æ•ˆæœå°æ¯”")
    print(f"   æœŸé–“: {BACKTEST_START} ~ {BACKTEST_END}")
    print(f"   æ¿¾ç¶²: Nasdaq 120MA + å€‹è‚¡ DC20 çªç ´")
    print("=" * 110)
    
    print(f"\n{'Ticker':>8} | {'Version':>12} | {'Return':>10} | {'CAGR':>8} | {'Sharpe':>8} | {'MDD':>10} | {'Trades':>6} | {'Win':>6}")
    print("-" * 110)
    
    for f, u in zip(filtered, unfiltered):
        if f is None:
            continue
        
        # Filtered
        print(f"{f['ticker']:>8} | {'Filtered':>12} | {f['total_return']:>9.1%} | {f['cagr']:>7.1%} | {f['sharpe_ratio']:>7.2f} | {f['max_drawdown']:>9.1%} | {f['total_trades']:>6} | {f['win_rate']:>5.1%}")
        
        # Unfiltered
        if u:
            mdd_diff = f['max_drawdown'] - u['max_drawdown']
            print(f"{'':>8} | {'No Filter':>12} | {u['total_return']:>9.1%} | {u['cagr']:>7.1%} | {u['sharpe_ratio']:>7.2f} | {u['max_drawdown']:>9.1%} | {u['total_trades']:>6} | {u['win_rate']:>5.1%}")
            print(f"{'':>8} | {'MDD Î”':>12} | {'':>10} | {'':>8} | {'':>8} | {mdd_diff:>+9.1%} | {'':>6} | {'':>6}")
        
        print("-" * 110)
    
    if benchmark:
        print(f"{'^IXIC':>8} | {'Buy & Hold':>12} | {benchmark['total_return']:>9.1%} | {benchmark['cagr']:>7.1%} | {benchmark['sharpe_ratio']:>7.2f} | {benchmark['max_drawdown']:>9.1%} | {'N/A':>6} | {'N/A':>6}")
    
    print("=" * 110)


# =============================================================================
# å‘½ä»¤åˆ—åƒæ•¸
# =============================================================================
def parse_args():
    parser = argparse.ArgumentParser(description='US Tech Stock Market Filter Backtest')
    parser.add_argument('--start', type=str, default=DEFAULT_START,
                        help=f'å›æ¸¬èµ·å§‹æ—¥æœŸ (é è¨­: {DEFAULT_START})')
    parser.add_argument('--end', type=str, default=DEFAULT_END,
                        help=f'å›æ¸¬çµæŸæ—¥æœŸ (é è¨­: {DEFAULT_END})')
    parser.add_argument('--tickers', type=str, nargs='+', default=TARGET_TICKERS,
                        help=f'å›æ¸¬æ¨™çš„ (é è¨­: {TARGET_TICKERS})')
    parser.add_argument('--no-filter', action='store_true',
                        help='åœç”¨å¸‚å ´æ¿¾ç¶² (åƒ…åŸ·è¡Œç„¡æ¿¾ç¶²ç‰ˆæœ¬)')
    return parser.parse_args()


# =============================================================================
# ä¸»ç¨‹å¼
# =============================================================================
def main():
    global BACKTEST_START, BACKTEST_END, OUTPUT_DIR
    
    args = parse_args()
    BACKTEST_START = args.start
    BACKTEST_END = args.end
    tickers = args.tickers
    
    # å‹•æ…‹è¼¸å‡ºç›®éŒ„ (åŒ…å«æ—¥æœŸç¯„åœ)
    start_short = BACKTEST_START.replace('-', '')
    end_short = BACKTEST_END.replace('-', '')
    OUTPUT_DIR = f"backtest_results_filtered_{start_short}_{end_short}"
    
    print("=" * 70)
    print("  US Tech Stock - å¸‚å ´æ¿¾ç¶²å›æ¸¬")
    print(f"  æœŸé–“: {BACKTEST_START} ~ {BACKTEST_END}")
    print(f"  æ¨™çš„: {', '.join(tickers)}")
    print(f"  æ¿¾ç¶²: Nasdaq 120MA + å€‹è‚¡ DC20 çªç ´")
    print(f"  è¼¸å‡º: {OUTPUT_DIR}/")
    print("=" * 70)
    
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    
    # è¼‰å…¥æ¨¡å‹
    print("\n[Step 1] è¼‰å…¥æ¨¡å‹...")
    manifest = load_model_manifest(MODELS_PATH)
    if manifest is None:
        print("âŒ ç„¡æ³•è¼‰å…¥ manifest")
        return
    
    # è¼‰å…¥åŸºæº–æŒ‡æ•¸
    print("\n[Step 2] è¼‰å…¥åŸºæº–æŒ‡æ•¸...")
    benchmark_df = load_or_update_local_csv(BENCHMARK)
    if benchmark_df is None:
        print("âŒ ç„¡æ³•è¼‰å…¥åŸºæº–æŒ‡æ•¸")
        return
    
    benchmark = calculate_benchmark(benchmark_df, BACKTEST_START, BACKTEST_END)
    
    # åŸ·è¡Œå›æ¸¬
    print("\n[Step 3] åŸ·è¡Œå›æ¸¬...")
    filtered_results = []
    unfiltered_results = []
    all_backtesters = {}
    all_features = {}
    
    for ticker in tickers:
        print(f"\nğŸ“ˆ {ticker}")
        print("-" * 40)
        
        model = load_ticker_model(ticker, manifest)
        if model is None:
            print(f"  âš ï¸ æ¨¡å‹è¼‰å…¥å¤±æ•—")
            filtered_results.append(None)
            unfiltered_results.append(None)
            continue
        print(f"  âœ… æ¨¡å‹è¼‰å…¥æˆåŠŸ")
        
        raw_df = load_or_update_local_csv(ticker)
        if raw_df is None:
            filtered_results.append(None)
            unfiltered_results.append(None)
            continue
        
        features_df = calculate_features(raw_df, benchmark_df, ticker, use_cache=True)
        all_features[ticker] = features_df
        
        # æœ‰æ¿¾ç¶²ç‰ˆæœ¬
        print(f"  [Filtered] Running...")
        backtester_filtered = FilteredBacktester(INITIAL_CAPITAL, use_filter=True)
        result_filtered = backtester_filtered.run(ticker, model, features_df, benchmark_df, 
                                                   BACKTEST_START, BACKTEST_END)
        filtered_results.append(result_filtered)
        all_backtesters[ticker] = backtester_filtered
        
        # ç„¡æ¿¾ç¶²ç‰ˆæœ¬
        print(f"  [No Filter] Running...")
        backtester_unfiltered = FilteredBacktester(INITIAL_CAPITAL, use_filter=False)
        result_unfiltered = backtester_unfiltered.run(ticker, model, features_df, benchmark_df,
                                                        BACKTEST_START, BACKTEST_END)
        unfiltered_results.append(result_unfiltered)
        
        if result_filtered:
            mdd_diff = result_filtered['max_drawdown'] - result_unfiltered['max_drawdown']
            print(f"  ğŸ“Š Filtered: Return={result_filtered['total_return']:.1%} | MDD={result_filtered['max_drawdown']:.1%} | MDD Î”={mdd_diff:+.1%}")
    
    # è¼¸å‡ºçµæœ
    print("\n[Step 4] è¼¸å‡ºçµæœ...")
    
    print_comparison_summary(filtered_results, unfiltered_results, benchmark)
    save_comparison_report(filtered_results, unfiltered_results, benchmark, OUTPUT_DIR)
    plot_equity_curves(filtered_results, unfiltered_results, benchmark, OUTPUT_DIR)
    
    # ç¹ªè£½å€‹è‚¡äº¤æ˜“è¨Šè™Ÿ
    for ticker in tickers:
        if ticker in all_backtesters and ticker in all_features:
            plot_trade_signals_filtered(ticker, all_features[ticker], benchmark_df,
                                        all_backtesters[ticker], OUTPUT_DIR)
    
    print("\n" + "=" * 70)
    print("  âœ… å›æ¸¬å®Œæˆï¼")
    print(f"  ğŸ“ çµæœå„²å­˜æ–¼: {OUTPUT_DIR}/")
    print("=" * 70)


if __name__ == "__main__":
    main()
